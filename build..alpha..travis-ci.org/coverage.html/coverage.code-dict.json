{"/home/travis/build/npmtest/node-npmtest-ember-paper/test.js":"/* istanbul instrument in package npmtest_ember_paper */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-ember-paper/lib.npmtest_ember_paper.js":"/* istanbul instrument in package npmtest_ember_paper */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_ember_paper = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_ember_paper = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-ember-paper/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-ember-paper && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_ember_paper */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_ember_paper\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_ember_paper.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_ember_paper.rollup.js'] =\n            local.assetsDict['/assets.npmtest_ember_paper.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_ember_paper.__dirname + '/lib.npmtest_ember_paper.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/index.js":"/* jshint node: true */\n'use strict';\n\nvar path = require('path');\nvar autoprefixer = require('broccoli-autoprefixer');\n\nmodule.exports = {\n  name: 'ember-paper',\n  blueprintsPath: function blueprintsPath() {\n    return path.join(__dirname, 'blueprints');\n  },\n  included: function(app) {\n    this._super.included(app);\n\n    if (!process.env.EMBER_CLI_FASTBOOT) {\n      app.import(app.bowerDirectory + '/hammer.js/hammer.js')\n      app.import(app.bowerDirectory + '/matchMedia/matchMedia.js');\n    };\n\n    app.import('vendor/propagating.js');\n  },\n  contentFor: function(type) {\n    if (type === 'body') {\n      return \"<div id='paper-wormhole'></div>\";\n    }\n  },\n  postprocessTree: function(type, tree) {\n    if (type === 'all' || type === 'styles') {\n      tree = autoprefixer(tree, { browsers: ['last 2 versions'] });\n    }\n    return tree;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/config/ember-try.js":"/*jshint node:true*/\nmodule.exports = {\n  scenarios: [\n    {\n      name: 'default',\n      dependencies: { }\n    },\n    {\n      name: 'ember-release',\n      dependencies: {\n        'ember': 'components/ember#release'\n      },\n      resolutions: {\n        'ember': 'release'\n      }\n    },\n    {\n      name: 'ember-beta',\n      dependencies: {\n        'ember': 'components/ember#beta'\n      },\n      resolutions: {\n        'ember': 'beta'\n      }\n    },\n    {\n      name: 'ember-canary',\n      dependencies: {\n        'ember': 'components/ember#canary'\n      },\n      resolutions: {\n        'ember': 'canary'\n      }\n    }\n  ]\n};\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/config/environment.js":"/*jshint node:true*/\n'use strict';\n\nmodule.exports = function(/* environment, appConfig */) {\n  return { };\n};\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/addon/components/base-focusable.js":"import Ember from 'ember';\nimport EventsMixin from '../mixins/events-mixin';\nimport HasBlockMixin from '../mixins/hasblock-mixin';\n\nexport default Ember.Component.extend(EventsMixin, HasBlockMixin, {\n  disabled: false,\n  pressed: false,\n  active: false,\n  focus: false,\n  hover: false,\n  attributeBindings: ['tabindex', 'disabledAttr:disabled'],\n\n  /*\n   * Not binding boolean values in Ember 1.8.1?\n   * https://github.com/emberjs/ember.js/issues/9595\n   */\n  disabledAttr: Ember.computed('disabled', function() {\n    return this.get('disabled') ? 'disabled' : null;\n  }),\n\n  //Alow element to be focusable by supplying a tabindex 0\n  tabindex: Ember.computed('disabled', function() {\n    return this.get('disabled') ? '-1' : '0';\n  }),\n\n  toggle: false,\n\n  /*\n   * Listen to `focusIn` and `focusOut` events instead of `focus` and `blur`.\n   * This way we don't need to explicitly bubble the events.\n   */\n  focusIn() {\n    if (!this.get('pressed')) {\n      // Only render the \"focused\" state if the element gains focus due to\n      // keyboard navigation.\n      this.set('focus', true);\n    }\n  },\n  focusOut() {\n    this.set('focus', false);\n  },\n  mouseEnter() {\n    this.set('hover', true);\n  },\n  mouseLeave(e) {\n    this.set('hover', false);\n    this._super(e);\n  },\n\n  down() {\n    this.set('pressed', true);\n    if (this.toggle) {\n      this.toggleProperty('active');\n    } else {\n      this.set('active', true);\n    }\n  },\n  up() {\n    this.set('pressed', false);\n\n    if (!this.toggle) {\n      this.set('active', false);\n    }\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/addon/components/paper-autocomplete-highlight.js":"import Ember from 'ember';\n\nexport default Ember.Component.extend({\n  tagName: 'span',\n  flags: '',\n\n  highlight: Ember.computed('searchText', 'label', 'flags', function() {\n    var unsafeText = Ember.Handlebars.Utils.escapeExpression(this.get('label'));\n    var text = unsafeText;\n    var flags = this.get('flags');\n    var regex = this.getRegExp(this.get('searchText'), flags);\n    var html  = text.replace(regex, '<span class=\"highlight\">$&</span>');\n    return new Ember.Handlebars.SafeString(html);\n  }),\n\n  sanitize(term) {\n    if (!term) {\n      return term;\n    }\n    return term.replace(/[\\\\\\^\\$\\*\\+\\?\\.\\(\\)\\|\\{}\\[\\]]/g, '\\\\$&');\n  },\n\n  getRegExp(text, flags) {\n    var str = '';\n    if (flags.indexOf('^') >= 1) {\n      str += '^';\n    }\n    str += text;\n    if (flags.indexOf('$') >= 1) {\n      str += '$';\n    }\n    return new RegExp(this.sanitize(str), flags.replace(/[\\$\\^]/g, ''));\n  }\n\n});\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/addon/components/paper-autocomplete-item.js":"import Ember from 'ember';\n\nexport default Ember.Component.extend({\n  tagName: 'li',\n  attributeBindings: ['tabindex', 'role'],\n  classNameBindings: ['isSelected:selected'],\n  tabindex: 0,\n  role: 'option',\n\n  label: Ember.computed('item', function() {\n    return this.lookupLabelOfItem(this.get('item'));\n  }),\n\n  isSelected: Ember.computed('selectedIndex', function() {\n    return this.get('selectedIndex') === this.get('index');\n  }),\n\n  lookupLabelOfItem(model) {\n    return this.get('lookupKey') ? Ember.get(model, this.get('lookupKey')) : model;\n  },\n\n  click() {\n    this.sendAction('pick', this.get('item'));\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/addon/components/paper-autocomplete.js":"import Ember from 'ember';\nimport HasBlockMixin from '../mixins/hasblock-mixin';\nimport { promiseArray } from 'ember-paper/utils/promise-proxies';\n\nconst {\n  get,\n  set,\n  setProperties,\n  isEmpty,\n  isEqual,\n  observer,\n  computed,\n  ObjectProxy,\n  run,\n  isArray,\n  assert,\n  isPresent,\n  getProperties\n} = Ember;\n\nconst {\n  not,\n  alias,\n  and,\n  bool\n} = computed;\n\nfunction isString(item) {\n  return typeof item === 'string' || item instanceof String;\n}\n\n/**\n * @name paper-autocomplete\n *\n * @description\n *     Provides material design autocomplete.\n *\n *\n * ## Dependencies\n * - paper-autocomplete-item\n * - paper-autocomplete-list\n * - paper-input\n * - paper-button\n * - input\n */\nexport default Ember.Component.extend(HasBlockMixin, {\n  util: Ember.inject.service(),\n  constants: Ember.inject.service(),\n\n  tagName: 'md-autocomplete',\n  classNameBindings: ['notFloating:md-default-theme'],\n  attributeBindings: ['floating:md-floating-label', 'showDisabled:disabled'],\n\n\n  // Internal\n  hidden: true,\n  selectedIndex: 0,\n  messages: [],\n  noBlur: false,\n  hasFocus: false,\n  searchText: '',\n  // wrap in a computed property so that cache\n  // isn't shared among autocomplete instances\n  itemCache: computed({\n    get(){\n      return {};\n    }\n  }),\n\n  // Public\n  fullTextSearch: false,\n  disabled: null,\n  required: null,\n  lookupKey: null,\n  placeholder: '',\n  delay: 0,\n  minLength: 1,\n  allowNonExisting: false,\n  noCache: false,\n  notFoundMessage: 'No matches found for \\'%@\\'.',\n\n  init() {\n    this._super(...arguments);\n    let model = get(this,'model');\n    if (model) {\n      // handle the case where model is a promise\n      if (model instanceof ObjectProxy){\n        model.then((instance)=>{\n          if (!isEmpty(instance)){\n            set(this,'searchText', this.lookupLabelOfItem(instance));\n            set(this,'model',instance);\n          }\n          // as this code would run async after the actual component\n          // init is made we need a way to monitor the fact of\n          // init finish in modelDidChange.\n          set(this,'initFinished', true);\n        });\n      } else {\n        set(this,'searchText', this.lookupLabelOfItem(get(this,'model')));\n        this.searchTextDidChange();\n        set(this,'initFinished',true);\n      }\n    }\n  },\n\n  notFloating: not('floating'),\n  notHidden: not('hidden'),\n\n  autocompleteWrapperId: computed('elementId', function() {\n    return `autocomplete-wrapper-${get(this,'elementId')}`;\n  }),\n\n  sections: {\n    itemTemplate: {isItemTemplate: true},\n    notFoundTemplate: {isNotFoundTemplate: true}\n  },\n\n  notFoundMsg: computed('searchText', 'notFoundMessage', function() {\n    return Ember.String.loc(this.get('notFoundMessage'), [this.get('searchText')]);\n  }),\n\n  /**\n   * Needed because of false = disabled='false'.\n   */\n  showDisabled: alias('disabled'),\n  notLoading: not('loading'),\n  notAllowNonExisting: not('allowNonExisting'),\n  notDebouncingState: not('debouncingState'),\n  enabled: not('disabled'),\n  showLoadingBar: and('notLoading', 'notAllowNonExisting', 'notDebouncingState'),\n  enableClearButton: and('searchText','enabled'),\n\n  /**\n   * Source filtering logic\n   */\n\n  searchTextDidChange: observer('searchText', function() {\n    let searchText = get(this,'searchText');\n    if (!isEqual(searchText, get(this,'previousSearchText'))) {\n      if (get(this,'notAllowNonExisting')) {\n        set(this,'model', null);\n      } else {\n        set(this,'model', searchText);\n      }\n\n      this.sendAction('update-filter', searchText);\n\n      set(this,'debouncingState', true);\n      run.debounce(this, 'setDebouncedSearchText', get(this,'delay'));\n      set(this,'previousSearchText', searchText);\n    }\n  }),\n  \n  finishModelChange(data){\n    let value = this.lookupLabelOfItem(data);\n    // First set previousSearchText then searchText ( do not trigger observer only update value! ).\n    set(this,'previousSearchText', value);\n    set(this,'searchText', value);\n    set(this,'hidden', true); \n  },\n\n  modelDidChange: observer('model', function() {\n    // we don't want this hook to run before the async init\n    // of the component finishes. null/undefined model value also\n    // breaks execution \n    if (get(this,'initFinished') && !isEmpty(get(this,'model'))){\n        let model = get(this,'model');\n        // sometimes model is a promise.\n        if (model.then) {\n          model.then((data)=>{\n            // the promise content might be null as well\n            if (!isEmpty(data)){\n              this.finishModelChange(data);\n            }\n          });\n        } else {\n          this.finishModelChange(model);\n        }\n      }\n  }),\n\n  setDebouncedSearchText() {\n    let searchText = get(this,'searchText');\n    if (get(this,'isMinLengthMet')) {\n      this.sendAction('debounced-update-filter', searchText);\n      if (!this.cacheGet(searchText)) {\n        this.sendAction('cache-miss', searchText);\n      } else {\n        this.sendAction('cache-hit', searchText);\n      }\n      this.set('debouncedSearchText', searchText);\n\n      // If the autocomplete is being triggered by a human / not on initial render.\n      if (this.get('hasFocus') || this.get('noBlur')) {\n        this.set('hidden', false);\n      }\n    } else {\n      this.set('hidden', true);\n    }\n    this.set('debouncingState', false);\n  },\n\n  loading: bool('sourcePromiseArray.isPending').readOnly(),\n\n  //coalesces all promises into PromiseArrays or Arrays\n  sourcePromiseArray: computed('source', function() {\n    let source = get(this,'source');\n    if (source && source.then) {\n      //coalesce into promise array\n      return promiseArray(source);\n    } else if (isArray(source)) {\n      //return array\n      return Ember.A(source);\n    } else {\n      //Unknown source type\n      assert('The provided \\'source\\' for paper-autocomplete must be an Array or a Promise.', !isPresent(source));\n      return Ember.A();\n    }\n  }).readOnly(),\n\n  suggestions: computed('debouncedSearchText', 'sourcePromiseArray.[]', function() {\n    var source = this.get('sourcePromiseArray');\n    var lookupKey = this.get('lookupKey');\n    var searchText = (this.get('debouncedSearchText') || '').toLowerCase();\n    var cachedItems = this.cacheGet(searchText);\n    var suggestions;\n\n    if (cachedItems) {\n      //We have cached results\n      suggestions = cachedItems;\n    } else {\n      //no cache\n\n      var data = this.filterArray(source, searchText, lookupKey);\n      if (source.then && source.get('isFulfilled')) {\n        //cache when we have a PromiseArray\n        this.cacheSet(searchText, data);\n      }\n      suggestions = Ember.A(data);\n    }\n    // If we have no item suggestions, and allowNonExisting is enabled\n    // We need to close the paper-autocomplete-list so all mouse events get activated again.\n    if (isEqual(suggestions.length,0) && get(this,'allowNonExisting')){\n      set(this,'hidden', true);\n    }\n    return suggestions;\n  }).readOnly(),\n\n\n  filterArray(array, searchText, lookupKey) {\n    return array.filter((item)=>{\n      assert(`You have not defined 'lookupKey' on paper-autocomplete, when source contained \\\n        items that are not of type String. To fix this error provide a \\\n        lookupKey='key to lookup from source item'.`, isString(item) || isPresent(lookupKey));\n\n      assert(`You specified '${lookupKey}' as a lookupKey on paper-autocomplete, \\\n        but at least one of its values is not of type String. To fix this error make sure that every \\\n        '${lookupKey}' value is a string.`,\n        isString(item) || (isPresent(lookupKey) && isString(get(item, lookupKey))) );\n\n      let search = isString(item) ? item.toLowerCase() : get(item, lookupKey).toLowerCase();\n      if (get(this,'fullTextSearch')){\n        return search.indexOf(searchText) !== -1;  \n      } else {\n        return search.indexOf(searchText) === 0;\n      }\n      \n    });\n  },\n\n  //TODO move cache to service? Components are not singletons.\n  cacheGet(text) {\n    return !get(this,'noCache') && get(this,'itemCache')[text];\n  },\n\n  cacheSet(text, data) {\n    get(this,'itemCache')[text] = data;\n  },\n\n  shouldHide: not('isMinLengthMet'),\n\n  isMinLengthMet: computed('searchText.length',{\n    get(){\n      return get(this,'searchText.length') >= get(this,'minLength');\n    }\n  }),\n\n  /**\n   * Returns the default index based on whether or not autoselect is enabled.\n   * @returns {number}\n   */\n  defaultIndex: computed('autoselect', function() {\n    return get(this,'autoselect') ? 0 : -1;\n  }),\n\n  lookupLabelOfItem(model) {\n    return get(this,'lookupKey') ? get(model, get(this,'lookupKey')) : model;\n  },\n\n  actions: {\n    clear() {\n      setProperties(this,{\n        searchText:'',\n        selectedIndex:-1,\n        model:null,\n        hidden:get(this,'shouldHide')\n      });\n    },\n\n    pickModel(model) {\n      let value = this.lookupLabelOfItem(model);\n      setProperties(this,{\n        model:model,\n        previousSearchText:value,\n        searchText:value,\n        hidden:true\n      });\n    },\n\n    inputFocusOut() {\n      set(this,'hasFocus', false);\n      if (get(this,'noBlur') === false) {\n        set(this,'hidden', true);\n      }\n    },\n\n    inputFocusIn() {\n      setProperties(this,{\n        hasFocus: true,\n        hidden: get(this,'shouldHide')\n      });\n    },\n\n    inputKeyDown(value, event) {\n      let {\n        constants,\n        selectedIndex,\n        suggestions\n      } = getProperties(this,\n        [\n        'constants',\n        'selectedIndex',\n        'suggestions'\n        ]);\n      switch (event.keyCode) {\n        case constants.KEYCODE.DOWN_ARROW:\n          if (get(this,'loading')) {\n            return;\n          }\n          set(this,'selectedIndex', Math.min(selectedIndex + 1, suggestions.length - 1));\n          break;\n        case constants.KEYCODE.UP_ARROW:\n          if (get(this,'loading')) {\n            return;\n          }\n          set(this,'selectedIndex', selectedIndex < 0 ? suggestions.length - 1 : Math.max(0, selectedIndex - 1));\n          break;\n        case constants.KEYCODE.TAB:\n        case constants.KEYCODE.ENTER:\n          if (get(this,'hidden') || get(this,'loading') || selectedIndex < 0 || suggestions.length < 1) {\n            return;\n          }\n          this.send('pickModel', suggestions.objectAt(selectedIndex));\n          break;\n        case constants.KEYCODE.ESCAPE:\n          setProperties(this,{\n            searchText:'',\n            selectedIndex:get(this,'defaultIndex'),\n            model:null,\n            hidden:get(this,'shouldHide')\n          });\n          break;\n        default:\n          break;\n      }\n    },\n\n    listMouseEnter() {\n      set(this,'noBlur', true);\n    },\n\n    listMouseLeave() {\n      set(this,'noBlur', false);\n      if (isEqual(get(this,'hasFocus'),false)) {\n        set(this,'hidden', true);\n      }\n    },\n\n    listMouseUp() {\n      this.$().find('input').focus();\n    }\n  }\n\n});\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/addon/components/paper-autocomplete-list.js":"import Ember from 'ember';\n\n//TODO Move to constants?\nvar ITEM_HEIGHT = 41,\n  MAX_HEIGHT = 5.5 * ITEM_HEIGHT,\n  MENU_PADDING = 8;\n\nexport default Ember.Component.extend({\n  util: Ember.inject.service(),\n\n  tagName: 'ul',\n  classNames: ['md-default-theme', 'md-autocomplete-suggestions', 'md-whiteframe-z1'],\n  attributeNameBindings: ['role'],\n  role: 'presentation',\n  stickToElement: null,\n\n  init() {\n    this._super(...arguments);\n    this._resizeWindowEvent = Ember.run.bind(this, this.resizeWindowEvent);\n  },\n\n  mouseEnter() {\n    this.sendAction('mouse-enter');\n  },\n\n  mouseLeave() {\n    this.sendAction('mouse-leave');\n  },\n\n  mouseUp() {\n    this.sendAction('mouse-up');\n  },\n\n  //TODO reafactor into a computed property that binds directly to dropdown's `style`\n  positionDropdown() {\n    var hrect  = Ember.$('#' + this.get('wrapToElementId'))[0].getBoundingClientRect(),\n      vrect  = hrect,\n      root   = document.body.getBoundingClientRect(),\n      top    = vrect.bottom - root.top,\n      bot    = root.bottom - vrect.top,\n      left   = hrect.left - root.left,\n      width  = hrect.width,\n      styles = {\n        left: left + 'px',\n        minWidth: width + 'px',\n        maxWidth: Math.max(hrect.right - root.left, root.right - hrect.left) - MENU_PADDING + 'px'\n      },\n      ul = this.$();\n\n    if (top > bot && root.height - hrect.bottom - MENU_PADDING < MAX_HEIGHT) {\n      styles.top = 'auto';\n      styles.bottom = bot + 'px';\n      styles.maxHeight = Math.min(MAX_HEIGHT, hrect.top - root.top - MENU_PADDING) + 'px';\n    } else {\n      styles.top = top + 'px';\n      styles.bottom = 'auto';\n      styles.maxHeight = Math.min(MAX_HEIGHT, root.bottom - hrect.bottom - MENU_PADDING) + 'px';\n    }\n    ul.css(styles);\n    correctHorizontalAlignment();\n\n    /**\n     * Makes sure that the menu doesn't go off of the screen on either side.\n     */\n    function correctHorizontalAlignment () {\n      var dropdown = ul[0].getBoundingClientRect(),\n        styles = {};\n      if (dropdown.right > root.right - MENU_PADDING) {\n        styles.left = (hrect.right - dropdown.width) + 'px';\n      }\n      ul.css(styles);\n    }\n  },\n\n  observeIndex: Ember.observer('selectedIndex', function() {\n    var suggestions = this.get('suggestions');\n    if (!suggestions || !suggestions.objectAt(this.get('selectedIndex'))) {\n      return;\n    }\n\n    var ul = this.$(),\n      li  = ul.find('li:eq('+this.get('selectedIndex')+')')[0],\n      top = li.offsetTop,\n      bot = top + li.offsetHeight,\n      hgt = ul[0].clientHeight;\n    if (top < ul[0].scrollTop) {\n      ul[0].scrollTop = top;\n    } else if (bot > ul[0].scrollTop + hgt) {\n      ul[0].scrollTop = bot - hgt;\n    }\n  }),\n\n  resizeWindowEvent() {\n    this.positionDropdown();\n  },\n\n  didInsertElement() {\n    this._super(...arguments);\n\n    //TODO refactor using ember-wormhole?\n    var ul = this.$().detach();\n    Ember.$('body').append(ul);\n    Ember.$(window).on('resize', this._resizeWindowEvent);\n    this.get('util').disableScrollAround(this.$());\n    this.positionDropdown();\n  },\n\n  willDestroyElement() {\n    Ember.$(window).off('resize', this._resizeWindowEvent);\n    this.get('util').enableScrolling();\n  }\n\n});\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/addon/components/paper-backdrop.js":"import Ember from 'ember';\nimport TransitionMixin from 'ember-css-transitions/mixins/transition-mixin';\n\n/* globals Hammer */\n\nexport default Ember.Component.extend(TransitionMixin, {\n  tagName: 'md-backdrop',\n  classNames: ['md-default-theme'],\n  classNameBindings: ['opaque:md-opaque', 'isLockedOpen:md-locked-open'],\n\n  // TransitionMixin:\n  transitionClass: 'ng',\n  shouldTransition: Ember.computed.bool('opaque'),\n  addDestroyedElementClone(parent, index, clone) {\n    parent.append(clone);\n  },\n\n  // Hammer event handler for tapping backdrop\n  tapHammer: null,\n\n\n  didInsertElement() {\n    var hammer = new Hammer(this.get('element'));\n    hammer.on('tap', Ember.run.bind(this, this.onTap));\n    this.set('tapHammer', hammer);\n  },\n\n  onTap(e) {\n    e.preventDefault();\n    this.sendAction('tap');\n  }\n\n});\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/addon/components/paper-button.js":"import Ember from 'ember';\nimport BaseFocusable from './base-focusable';\nimport RippleMixin from '../mixins/ripple-mixin';\nimport ProxiableMixin from 'ember-paper/mixins/proxiable-mixin';\nimport ColorMixin from 'ember-paper/mixins/color-mixin';\n\nexport default BaseFocusable.extend(RippleMixin, ProxiableMixin, ColorMixin, {\n  attributeBindings: ['target', 'action', 'type'],\n  tagName: 'button',\n  themed: true,\n  classNameBindings: ['raised:md-raised', 'icon-button:md-icon-button', 'focus:md-focused', 'themed:md-default-theme', 'themed:md-button'],\n\n\n  noSpan: Ember.computed('no-span', function () {\n    return this.get('no-span');\n  }),\n\n  /* RippleMixin overrides */\n  focus: false,\n  isIconButton: Ember.computed(function() {\n    return this.classNames.any(function(className) {\n      return className.indexOf('md-icon-button') !== -1;\n    });\n  }),\n  isMenuItem: Ember.computed(function() {\n    return this.classNames.any(function(className) {\n      return className.indexOf('md-menu-item') !== -1;\n    });\n  }),\n  center: Ember.computed.alias('isIconButton'),\n  fitRipple: Ember.computed.alias('isIconButton'),\n\n  dimBackground: Ember.computed.not('isIconButton'),\n\n  //bubble actions by default\n  bubbles: true,\n  click() {\n    var target = this.get('target');\n\n    if (target) {\n      this.get('target').send(this.get('action'), this.get('param'));\n    } else {\n      this.sendAction('action', this.get('param'));\n    }\n\n    return this.get('bubbles');\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/addon/components/paper-card-content.js":"import Ember from 'ember';\nimport FlexMixin from '../mixins/flex-mixin';\n\nexport default Ember.Component.extend(FlexMixin, {\n  tagName: 'md-card-content',\n  classNames: ['paper-card-content']\n});\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/addon/components/paper-card-footer.js":"import Ember from 'ember';\nimport FlexMixin from '../mixins/flex-mixin';\n\nexport default Ember.Component.extend(FlexMixin, {\n  tagName: 'md-card-footer',\n  classNames: ['paper-card-footer']\n});\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/addon/components/paper-card.js":"import Ember from 'ember';\nimport FlexMixin from '../mixins/flex-mixin';\n\nexport default Ember.Component.extend(FlexMixin, {\n  tagName: 'md-card',\n  classNames: ['paper-card']\n});\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/addon/components/paper-card-title.js":"import Ember from 'ember';\nimport FlexMixin from '../mixins/flex-mixin';\n\nexport default Ember.Component.extend(FlexMixin, {\n  tagName: 'md-card-title',\n});\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/addon/components/paper-card-title-media.js":"import Ember from 'ember';\nimport FlexMixin from '../mixins/flex-mixin';\n\nexport default Ember.Component.extend(FlexMixin, {\n  tagName: 'md-card-title-media',\n});\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/addon/components/paper-card-title-text.js":"import Ember from 'ember';\nimport FlexMixin from '../mixins/flex-mixin';\n\nexport default Ember.Component.extend(FlexMixin, {\n  tagName: 'md-card-title-text',\n  classNames: ['paper-card-title-text']\n});\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/addon/components/paper-checkbox.js":"import Ember from 'ember';\nimport BaseFocusable from './base-focusable';\nimport RippleMixin from '../mixins/ripple-mixin';\nimport ProxiableMixin from 'ember-paper/mixins/proxiable-mixin';\nimport ColorMixin from 'ember-paper/mixins/color-mixin';\n\nexport default BaseFocusable.extend(RippleMixin, ProxiableMixin, ColorMixin, {\n  tagName: 'md-checkbox',\n  classNames: ['md-checkbox', 'md-default-theme'],\n  classNameBindings: ['checked:md-checked'],\n\n  constants: Ember.inject.service(),\n\n  checked: false,\n  toggle: true,\n\n  /* RippleMixin overrides */\n  center: true,\n  dimBackground: false,\n  fitRipple: true,\n  rippleContainerSelector: '.md-container',\n\n  //bubble actions by default\n  bubbles: true,\n  click() {\n    if (!this.get('disabled')) {\n      this.toggleProperty('checked');\n    }\n    return this.get('bubbles');\n  },\n\n  keyPress(ev) {\n    if (ev.which === this.get('constants.KEYCODE.SPACE')) {\n      this.click();\n    }\n  },\n\n  processProxy() {\n    this.toggleProperty('checked');\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/addon/components/paper-content.js":"import Ember from 'ember';\nimport FlexMixin from '../mixins/flex-mixin';\n\nexport default Ember.Component.extend(FlexMixin, {\n  tagName: 'md-content',\n  classNames: ['md-default-theme'],\n  attributeBindings: ['layout-padding', 'scroll-y:md-scroll-y'],\n  classNameBindings: ['padding:md-padding'],\n\n\n});\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/addon/components/paper-divider.js":"import Ember from 'ember';\n\nexport default Ember.Component.extend({\n  tagName: 'md-divider',\n  attributeBindings: ['insetAttr:md-inset'],\n  classNames: ['paper-divider','md-default-theme'],\n  /*\n   * Not binding boolean values in Ember 1.8.1?\n   * https://github.com/emberjs/ember.js/issues/9595\n   */\n  insetAttr: Ember.computed('inset', function() {\n    return this.get('inset') ? 'md-inset' : null;\n  })\n});\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/addon/components/paper-grid-list.js":"import Ember from 'ember';\nimport gridLayout from '../utils/grid-layout';\n\nconst UNIT = (units) => {\n  return `${units.share}% - (${units.gutter} * ${units.gutterShare})`;\n};\n\nconst POSITION = (positions) => {\n  return `calc((${positions.unit} + ${positions.gutter}) * ${positions.offset})`;\n};\n\nconst DIMENSION = (dimensions) => {\n  return `calc((${dimensions.unit}) * ${dimensions.span} + (${dimensions.span} - 1) * ${dimensions.gutter})`;\n};\n\nconst MEDIA = (mediaName) => {\n  return ((mediaName.charAt(0) !== '(') ? ('(' + mediaName + ')') : mediaName);\n};\n\nexport default Ember.Component.extend({\n  tagName: 'md-grid-list',\n\n  constants: Ember.inject.service(),\n\n  layoutInvalidated: false,\n  tilesInvalidated: false,\n  lastLayoutProps: {},\n  tiles: Ember.computed(function() {\n    return Ember.A();\n  }),\n\n  _invalidateLayoutListener: Ember.computed(function() {\n    return Ember.run.bind(this, () => {\n      this.send('invalidateLayout');\n    });\n  }),\n\n  didInsertElement() {\n    this._super(...arguments);\n    this._watchMedia();\n    this._watchResponsiveAttributes(['md-cols', 'md-row-height', 'md-gutter'], Ember.run.bind(this, this.layoutIfMediaMatch));\n\n  },\n\n  willDestroyElement() {\n    this._super(...arguments);\n    this._unwatchMedia();\n  },\n\n  registerGridTile(gridTile) {\n    this.get('tiles').addObject(gridTile);\n  },\n\n  layout() {\n    try {\n      var tilesInvalidated = this.get('tilesInvalidated');\n      this._layoutDelegate(tilesInvalidated);\n    } finally {\n      this.setProperties({\n        'layoutInvalidated': false,\n        'tilesInvalidated': false\n      });\n    }\n  },\n\n  layoutIfMediaMatch(mediaName) {\n    if (mediaName == null) {\n      this.send('invalidateLayout');\n    } else if (window.matchMedia(mediaName)) {\n      this.send('invalidateLayout');\n    }\n  },\n\n  _watchMedia() {\n\n    const invalidateLayoutListener = this.get('_invalidateLayoutListener');\n\n    for (var mediaName in this.get('constants.MEDIA')) {\n      var query = this.get('constants.MEDIA')[mediaName] || MEDIA(mediaName);\n      window.matchMedia(query).addListener(invalidateLayoutListener);\n    }\n  },\n\n  _watchResponsiveAttributes(attrNames, watchFn) {\n    const checkObserverValues = (sender, key, mediaName) => {\n      const oldValue = sender.get(`old${key}`),\n            newValue = sender.get(key);\n\n      if (oldValue !== newValue) {\n        watchFn(mediaName);\n      }\n\n    };\n\n    attrNames.forEach((attrName) => {\n      if (Ember.get(this, attrName)) {\n        this.set(`old${attrName}`, Ember.get(this, attrName));\n\n        var customObserver = Ember.run.bind(this, checkObserverValues, this, attrName);\n\n        this.addObserver(attrName, customObserver);\n      }\n\n      for (var mediaName in this.get('constants.MEDIA')) {\n        var normalizedName = attrName + '-' + mediaName;\n        if (Ember.get(this, normalizedName)) {\n          var customObserverNormalized = Ember.run.bind(this, checkObserverValues, this, normalizedName, mediaName);\n          this.addObserver(normalizedName, customObserverNormalized);\n        }\n      }\n\n    });\n  },\n\n  _unwatchMedia() {\n    const invalidateLayoutListener = this.get('_invalidateLayoutListener');\n    for(var mediaName in this.get('constants.MEDIA')) {\n      var query = this.get('constants.MEDIA')[mediaName] || MEDIA(mediaName);\n      window.matchMedia(query).removeListener(invalidateLayoutListener);\n    }\n  },\n\n  _getResponsiveAttribute(component, attrName) {\n    const mediaPriorities = this.get('constants.MEDIA_PRIORITY');\n    for (var i = 0; i < mediaPriorities.length; i++) {\n      var mediaName = mediaPriorities[i],\n          query = this.get('constants.MEDIA')[mediaName] || MEDIA(mediaName);\n\n      if (!window.matchMedia(query).matches) {\n        continue;\n      }\n\n      var normalizedName = attrName + '-' + mediaName;\n      if (Ember.get(component, normalizedName)) {\n        return Ember.get(component, normalizedName);\n      }\n    }\n\n    // fallback on unprefixed\n    return Ember.get(component, attrName);\n  },\n\n\n\n  _getTileStyle(position, spans, colCount, rowCount, gutter, rowMode, rowHeight) {\n\n    // Percent of the available horizontal space that one column takes up.\n    const hShare = (1 / colCount) * 100;\n\n    // Fraction of the gutter size that each column takes up.\n    const hGutterShare = (colCount - 1) / colCount;\n\n    // Base horizontal size of a column.\n    const hUnit = UNIT({share: hShare, gutterShare: hGutterShare, gutter: gutter});\n\n    // The width and horizontal position of each tile is always calculated the same way, but the\n    // height and vertical position depends on the rowMode.\n    const style = {\n      left: POSITION({unit: hUnit, offset: position.col, gutter: gutter}),\n      width: DIMENSION({unit: hUnit, span: spans.col, gutter: gutter}),\n      //resets\n      paddingTop: '',\n      marginTop: '',\n      top: '',\n      height: ''\n    };\n\n    let vShare, vUnit;\n\n    switch (rowMode) {\n      case 'fixed':\n        // In fixed mode, simply use the given rowHeight.\n        style.top = POSITION({unit: rowHeight, offset: position.row, gutter: gutter});\n        style.height = DIMENSION({unit: rowHeight, span: spans.row, gutter: gutter});\n        break;\n\n      case 'ratio':\n        // Percent of the available vertical space that one row takes up. Here, rowHeight holds\n        // the ratio value. For example, if the width:height ratio is 4:3, rowHeight = 1.333.\n        vShare = hShare / rowHeight;\n\n        // Base veritcal size of a row.\n        vUnit = UNIT({share: vShare, gutterShare: hGutterShare, gutter: gutter});\n\n        // padidngTop and marginTop are used to maintain the given aspect ratio, as\n        // a percentage-based value for these properties is applied to the *width* of the\n        // containing block. See http://www.w3.org/TR/CSS2/box.html#margin-properties\n        style.paddingTop = DIMENSION({unit: vUnit, span: spans.row, gutter: gutter});\n        style.marginTop = POSITION({unit: vUnit, offset: position.row, gutter: gutter});\n        break;\n\n      case 'fit':\n        // Fraction of the gutter size that each column takes up.\n        var vGutterShare = (rowCount - 1) / rowCount;\n\n        // Percent of the available vertical space that one row takes up.\n        vShare = (1 / rowCount) * 100;\n\n        // Base vertical size of a row.\n        vUnit = UNIT({share: vShare, gutterShare: vGutterShare, gutter: gutter});\n\n        style.top = POSITION({unit: vUnit, offset: position.row, gutter: gutter});\n        style.height = DIMENSION({unit: vUnit, span: spans.row, gutter: gutter});\n        break;\n    }\n\n    return style;\n\n  },\n\n  _getGridStyle(colCount, rowCount, gutter, rowMode, rowHeight) {\n    const style = {};\n\n    switch (rowMode) {\n      case 'fixed':\n        style.height = DIMENSION({unit: rowHeight, span: rowCount, gutter: gutter});\n        style.paddingBottom = '';\n        break;\n      case 'ratio':\n        // rowHeight is width / height\n        const hGutterShare = colCount === 1 ? 0 : (colCount - 1) / colCount,\n          hShare = (1 / colCount) * 100,\n          vShare = hShare * (1 / rowHeight),\n          vUnit = UNIT({share: vShare, gutterShare: hGutterShare, gutter: gutter});\n\n        style.height = '';\n        style.paddingBottom = DIMENSION({unit: vUnit, span: rowCount, gutter: gutter});\n        break;\n      case 'fit':\n        // noop, as the height is user set\n        break;\n    }\n\n    return style;\n  },\n\n  _getTileSpans(tileElements) {\n    return [].map.call(tileElements, (ele) => {\n      return {\n        row: parseInt(this._getResponsiveAttribute(ele, 'md-rowspan'), 10) || 1,\n        col: parseInt(this._getResponsiveAttribute(ele, 'md-colspan'), 10) || 1\n      };\n    });\n  },\n\n  _getColumnCount() {\n    const colCount = parseInt(this._getResponsiveAttribute(this, 'md-cols'), 10);\n    if (isNaN(colCount)) {\n      throw 'md-grid-list: md-cols attribute was not found, or contained a non-numeric value';\n    }\n    return colCount;\n  },\n\n  _getGutter() {\n    return this._applyDefaultUnit(this._getResponsiveAttribute(this, 'md-gutter') || 1);\n  },\n\n  _getRowHeight() {\n    const rowHeight = this._getResponsiveAttribute(this, 'md-row-height');\n    switch (this._getRowMode()) {\n      case 'fixed':\n        return this._applyDefaultUnit(rowHeight);\n      case 'ratio':\n        var whRatio = rowHeight.split(':');\n        return parseFloat(whRatio[0]) / parseFloat(whRatio[1]);\n      case 'fit':\n        return 0;\n    }\n  },\n\n  _getRowMode() {\n    const rowHeight = this._getResponsiveAttribute(this, 'md-row-height');\n    if (rowHeight === 'fit') {\n      return 'fit';\n    } else if (rowHeight.indexOf(':') !== -1) {\n      return 'ratio';\n    } else {\n      return 'fixed';\n    }\n  },\n\n\n  _layoutDelegate(tilesInvalidated) {\n    const tiles = this.get('tiles');\n    const props = {\n      tileSpans: this._getTileSpans(tiles),\n      colCount: this._getColumnCount(),\n      rowMode: this._getRowMode(),\n      rowHeight: this._getRowHeight(),\n      gutter: this._getGutter()\n    };\n\n    if (!tilesInvalidated && Ember.isEqual(props, this.get('lastLayoutProps'))) {\n      return;\n    }\n\n    gridLayout(props.colCount, props.tileSpans, tiles)\n      .map((tilePositions, rowCount) => {\n        return {\n          grid: {\n            element: this.$(),\n            style: this._getGridStyle(props.colCount, rowCount, props.gutter, props.rowMode, props.rowHeight)\n          },\n          tiles: tilePositions.map((ps, i) => {\n            return {\n              element: tiles[i].$(),\n              style: this._getTileStyle(ps.position, ps.spans, props.colCount, rowCount, props.gutter, props.rowMode, props.rowHeight)\n            };\n          })\n        };\n      })\n      .reflow();\n\n    this.set('lastLayoutProps', props);\n\n  },\n\n  _applyDefaultUnit(val) {\n    return /\\D$/.test(val) ? val : val + 'px';\n  },\n\n  actions: {\n    invalidateTiles() {\n      this.set('tilesInvalidated', true);\n      this.send('invalidateLayout');\n    },\n\n    invalidateLayout() {\n      if (this.get('layoutInvalidated') || this.get('isDestroyed') || this.get('isDestroying')) {\n        return;\n      }\n      this.set('layoutInvalidated', true);\n      Ember.run.next(this, this.layout);\n    }\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/addon/components/paper-grid-tile-footer.js":"import Ember from 'ember';\n\nexport default Ember.Component.extend({\n  tagName: 'md-grid-tile-footer'\n});\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/addon/components/paper-grid-tile.js":"import Ember from 'ember';\nimport PaperGridList from './paper-grid-list';\n\nexport default Ember.Component.extend({\n  tagName: 'md-grid-tile',\n\n  constants: Ember.inject.service(),\n\n  didInsertElement() {\n    this._super(...arguments);\n\n    this.get('gridList').registerGridTile(this);\n    this.get('gridList').send('invalidateTiles');\n\n    this._watchResponsiveAttributes(['md-colspan', 'md-rowspan'], (mediaName) => {\n      this.get('gridList').send('invalidateLayout', mediaName);\n    });\n  },\n\n  willDestroyElement() {\n    this._super(...arguments);\n\n    this.get('gridList').send('invalidateLayout');\n\n  },\n\n  gridList: Ember.computed(function() {\n    return this.nearestOfType(PaperGridList);\n  }),\n\n  _watchResponsiveAttributes(attrNames, watchFn) {\n\n    const checkObserverValues = (sender, key) => {\n      const oldValue = this.get(`old${key}`),\n            newValue = sender.get(key);\n\n      if (oldValue !== newValue) {\n        watchFn();\n      }\n    };\n\n    attrNames.forEach((attrName) => {\n      if (Ember.get(this, attrName)) {\n        this.set('old' + attrName, Ember.get(this, attrName));\n\n        this.addObserver(attrName, checkObserverValues);\n      }\n\n      for (var mediaName in this.get('constants.MEDIA')) {\n        var normalizedName = attrName + '-' + mediaName;\n        if (Ember.get(this, normalizedName)) {\n          this.set('old' + normalizedName, Ember.get(this, normalizedName));\n\n          this.addObserver(normalizedName, checkObserverValues);\n        }\n      }\n\n    });\n  }\n\n\n});\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/addon/components/paper-icon.js":"import Ember from 'ember';\nimport ColorMixin from 'ember-paper/mixins/color-mixin';\n\nvar PaperIconComponent = Ember.Component.extend(ColorMixin, {\n  tagName: 'md-icon',\n  classNames: ['paper-icon', 'md-font', 'material-icons', 'md-default-theme'],\n  classNameBindings: ['iconClass', 'sizeClass', 'spinClass'],\n  attributeBindings: ['aria-label'],\n\n  icon: '',\n  spin: false,\n  reverseSpin: false,\n\n  iconClass: Ember.computed('icon', 'positionalIcon', function() {\n    var icon = this.getWithDefault('positionalIcon', this.get('icon'));\n    return Ember.String.dasherize(icon);\n  }),\n\n  'aria-label': Ember.computed.reads('iconClass'),\n\n  spinClass: Ember.computed('spin', 'reverseSpin', function() {\n    if (this.get('spin')) {\n      return 'md-spin';\n    } else if (this.get('reverseSpin')) {\n      return 'md-spin-reverse';\n    }\n  }),\n\n  sizeClass : Ember.computed('size', function() {\n    switch(this.get('size')) {\n      case 'lg':\n        return 'md-lg';\n      case 'sm':\n        return 'md-sm';\n      case 2:\n        return 'md-2x';\n      case 3:\n        return 'md-3x';\n      case 4:\n        return 'md-4x';\n      case 5:\n        return 'md-5x';\n    }\n  })\n});\n\nPaperIconComponent.reopenClass({\n  positionalParams: ['positionalIcon']\n});\n\nexport default PaperIconComponent;\n\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/addon/components/paper-input.js":"import Ember from 'ember';\nimport BaseFocusable from './base-focusable';\nimport ColorMixin from 'ember-paper/mixins/color-mixin';\nimport FlexMixin from 'ember-paper/mixins/flex-mixin';\n\nexport default BaseFocusable.extend(ColorMixin, FlexMixin, {\n  tagName: 'md-input-container',\n  classNames: ['md-default-theme'],\n  classNameBindings: ['hasValue:md-input-has-value', 'focus:md-input-focused', 'isInvalid:md-input-invalid', 'iconFloat:md-icon-float'],\n  type: 'text',\n  autofocus: false,\n  tabindex: -1,\n  hideAllMessages: false,\n  hasValue: Ember.computed.notEmpty('value'),\n  inputElementId: Ember.computed('elementId', function() {\n    return 'input-' + this.get('elementId');\n  }),\n  isInvalid: Ember.computed('isTouched', 'value', function() {\n    return this.validate();\n  }),\n  renderCharCount: Ember.computed('value', function() {\n    var currentLength = this.get('value') ? this.get('value').length : 0;\n    return currentLength + '/' + this.get('maxlength');\n  }),\n  iconFloat: Ember.computed.and('icon', 'label'),\n\n  didInsertElement() {\n    if (this.get('textarea')) {\n      this.setupTextarea();\n    }\n  },\n\n  setupTextarea() {\n    var textarea = this.$().children('textarea').first(),\n    textareaNode = textarea[0],\n    container = this.get('element'),\n    minRows = NaN,\n    lineHeight = null;\n\n    if (textareaNode.hasAttribute('rows')) {\n      minRows = parseInt(textareaNode.getAttribute('rows'));\n    }\n\n    textarea.on('keydown input', () => {\n      this.growTextarea(textarea, textareaNode, container, minRows, lineHeight);\n    });\n\n    if (isNaN(minRows)) {\n      textarea.attr('rows','1');\n\n      textarea.on('scroll', () => {\n        this.onScroll(textareaNode);\n      });\n    }\n\n    Ember.$(window).on('resize', this.growTextarea(textarea, textareaNode, container, minRows, lineHeight));\n  },\n\n  growTextarea(textarea, textareaNode, container, minRows, lineHeight) {\n    // sets the md-input-container height to avoid jumping around\n    container.style.height = container.offsetHeight+'px';\n\n    // temporarily disables element's flex so its height 'runs free'\n    textarea.addClass('md-no-flex');\n\n    if(isNaN(minRows)) {\n      textareaNode.style.height = \"auto\";\n      textareaNode.scrollTop = 0;\n      var height = this.getHeight(textareaNode);\n      if (height) {\n        textareaNode.style.height = height + 'px';\n      }\n    } else {\n      textareaNode.setAttribute(\"rows\", 1);\n\n      if(!lineHeight) {\n        textareaNode.style.minHeight = '0';\n\n        lineHeight = textarea.prop('clientHeight');\n\n        textareaNode.style.minHeight = null;\n      }\n\n      var rows = Math.max(minRows, Math.round(textareaNode.scrollHeight / lineHeight));\n      textareaNode.setAttribute(\"rows\", rows);\n    }\n\n    // reset everything back to normal\n    textarea.removeClass('md-no-flex');\n    container.style.height = 'auto';\n  },\n\n  getHeight(node) {\n    var line = node.scrollHeight - node.offsetHeight;\n    return node.offsetHeight + (line > 0 ? line : 0);\n  },\n\n  onScroll(node) {\n    node.scrollTop = 0;\n    // for smooth new line adding\n    var line = node.scrollHeight - node.offsetHeight;\n    var height = node.offsetHeight + line;\n    node.style.height = height + 'px';\n  },\n\n  willDestroyElement() {\n    Ember.$(window).off('resize', this.growTextarea);\n  },\n\n  validate() {\n\n    if (!this.get('isTouched')) {\n      return false;\n    }\n\n    var valueIsInvalid = false;\n    var currentValue = this.get('value');\n    var constraints = [\n      {\n        attr: 'required',\n        defaultError: 'This is required.',\n        isError: () => this.get('required') && !this.get('hasValue')\n      },\n      {\n        attr: 'min',\n        defaultError: 'Must be at least ' + this.get('min') + '.',\n        isError: () => +currentValue < +this.get('min')\n      },\n      {\n        attr: 'max',\n        defaultError: 'Must be less than ' + this.get('max') + '.',\n        isError: () => +currentValue > +this.get('max')\n      },\n      {\n        attr: 'maxlength',\n        defaultError: 'Must not exceed ' + this.get('maxlength') + ' characters.',\n        isError: () => currentValue && currentValue.length > +this.get('maxlength')\n      }\n    ];\n\n    constraints.some(thisConstraint => {\n      if(thisConstraint.isError()) {\n        this.setError(thisConstraint);\n        valueIsInvalid = true;\n        return true;\n      }\n    });\n\n    if (valueIsInvalid === true) {\n      return true;\n    }\n\n    if (!Ember.isEmpty(this.get('customValidation'))) {\n      var validationObjects = Ember.A();\n      var self = this;\n      var validationObjectsLength;\n\n      try {\n        if (!Ember.isArray(this.get('customValidation'))) {\n          validationObjects.addObject(this.get('customValidation'));\n        } else {\n          validationObjects = this.get('customValidation');\n        }\n\n        validationObjectsLength = validationObjects.length;\n        for (var i = 0; i < validationObjectsLength; i++) {\n          if (typeof validationObjects[i].isError === 'function') {\n            if (validationObjects[i].isError.apply(null, [currentValue]) === true) {\n              self.setError(validationObjects[i]);\n              valueIsInvalid = true;\n              break;\n            }\n          }\n        }\n      } catch (error) {\n        Ember.Logger.error('Exception with custom validation: ', error);\n      }\n\n    }\n\n    return valueIsInvalid;\n  },\n\n  setError(constraint) {\n    this.set('ng-message', constraint.attr || 'custom');\n    this.set('errortext', this.get(constraint.attr + '-errortext') || constraint.defaultError || constraint.errorMessage);\n  },\n\n  actions: {\n    focusIn(value) {\n      // We resend action so other components can take use of the actions also ( if they want ).\n      // Actions must be sent before focusing.\n      this.sendAction('focus-in', value);\n      this.set('focus',true);\n    },\n    focusOut(value) {\n      this.sendAction('focus-out', value);\n      this.set('focus',false);\n      this.set('isTouched', true);\n    },\n    keyDown(value, event) {\n      this.sendAction('key-down', value, event);\n    }\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/addon/components/paper-item.js":"import Ember from 'ember';\nimport RippleMixin from '../mixins/ripple-mixin';\nimport ProxyMixin from 'ember-paper/mixins/proxy-mixin';\n\nexport default Ember.Component.extend(RippleMixin, ProxyMixin, {\n  tagName: 'md-list-item',\n\n  /* RippleMixin overrides */\n  center: false,\n  dimBackground: true,\n  outline: false,\n  isMenuItem: true,\n  fullRipple: true,\n  rippleContainerSelector: '.md-no-style',\n\n  noink: Ember.computed.not('shouldBeClickable'),\n\n  classNameBindings: ['shouldBeClickable:md-clickable', 'hasProxiedComponent:md-proxy-focus'],\n  attributeBindings: ['role', 'tabindex'],\n  role: 'listitem',\n  tabindex: '-1',\n\n  hasProxiedComponent: Ember.computed.bool('proxiedComponents.length'),\n\n  hasSecondaryAction: Ember.computed('secondaryItem', 'action', function() {\n    var secondaryItem = this.get('secondaryItem');\n    return secondaryItem && (secondaryItem.action || (this.get('action') && this.isProxiedComponent(secondaryItem)));\n  }),\n\n  secondaryItem: Ember.computed('proxiedComponents.[]', function() {\n    var proxiedComponents = this.get('proxiedComponents');\n    return proxiedComponents.find(function(component) {\n      return component.classNames.indexOf('md-secondary') !== -1;\n    });\n  }),\n\n  shouldBeClickable: Ember.computed('proxiedComponents.length', 'action', function() {\n    return this.get('proxiedComponents.length') || this.get('action');\n  }),\n\n  didInsertElement() {\n    this._super(...arguments);\n\n    var _this = this,\n      tEl = this.$(),\n      proxies = this.get('proxiedComponents');\n\n    //Secondary item has separate action.\n    //Unregister so we don't proxy it.\n    if (this.get('hasSecondaryAction')) {\n      this.get('secondaryItem').set('bubbles', false);\n      this.unregister(this.get('secondaryItem'));\n    }\n\n    // Allow proxied component to propagate ripple hammer event\n    this.get('proxiedComponents').forEach(function(component) {\n      if (!component.get('action')) {\n        component.set('propagateRipple', true);\n      }\n    });\n    // Don't allow proxied component to bubble click event to parent list-item\n    this.get('proxiedComponents').setEach('bubbles', false);\n\n    this.$('.md-icon-button').addClass('md-secondary-container');\n\n    if (this.get('hasProxiedComponent')) {\n      proxies.forEach(function(view) {\n        var el = view.$();\n\n        _this.mouseActive = false;\n        el.on('mousedown', function() {\n          _this.mouseActive = true;\n          Ember.run.later(function(){\n            _this.mouseActive = false;\n          }, 100);\n        }).on('focus', function() {\n            if (_this.mouseActive === false) {\n              tEl.addClass('md-focused');\n            }\n            el.on('blur', function proxyOnBlur() {\n              tEl.removeClass('md-focused');\n              el.off('blur', proxyOnBlur);\n            });\n          });\n      });\n    }\n\n    if (!this.get('shouldBeClickable')) {\n      let firstChild = tEl.find(\">:first-child\");\n      firstChild.on('keypress', function(e) {\n        var tagName = Ember.$(e.target).prop(\"tagName\");\n        if (tagName !== 'INPUT' && tagName !== 'TEXTAREA') {\n          var keyCode = e.which || e.keyCode;\n          if (keyCode === 32) {\n            if (firstChild) {\n              firstChild.click();\n              e.preventDefault();\n              e.stopPropagation();\n            }\n          }\n        }\n      });\n    }\n  },\n\n  actions: {\n    buttonAction() {\n      this.get('proxiedComponents').forEach(function(component) {\n        if (component.processProxy) {\n          component.processProxy();\n        }\n      });\n      this.sendAction('action', this.get('param'));\n    }\n  }\n\n});\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/addon/components/paper-list.js":"import Ember from 'ember';\n\nexport default Ember.Component.extend({\n  tagName: 'md-list',\n  classNames: ['paper-list', 'md-default-theme']\n});\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/addon/components/paper-menu-abstract.js":"import Ember from 'ember';\n\nexport default Ember.Component.extend({\n  constants: Ember.inject.service(),\n\n  'is-open': false,\n\n  /* this is true when toggleMenu action is called, but only turns false when animation to hide the wrapper is done. */\n  isOpen: Ember.computed.alias('is-open'),\n\n  /* Supports a on-open that can return a promise, menu is not opened before this promise is resolved by the origin. */\n  onOpen: Ember.computed.alias('on-open'),\n\n  /* async: is true if promise was not resolved. */\n  isLoading: false,\n\n  /* cache async requests */\n  cache: true,\n\n  preventMenuOpen: false,\n\n  itemLabelCallback: Ember.computed.alias('item-label-callback'),\n\n\n  actions: {\n\n    toggleMenu() {\n      var _self = this;\n      if (this.get('isOpen')) {\n        this.get('activeWrapper').hideWrapper().then(function () {\n          _self.set('isOpen', false);\n        });\n      } else {\n        if (this.get('preventMenuOpen')) {\n          return;\n        }\n        if (this.get('onOpen') && (!this.get('items') || this.get('cache') === false)) {\n          _self.set('activeWrapper', null);\n          _self.set('isLoading', true);\n          _self.set('isOpen', true);\n          var promise = this.get('onOpen').call(this);\n          promise.then(function (data) {\n            _self.set('items', data);\n            _self.set('isLoading', false);\n          }, function () {\n            _self.set('items', Ember.A([]));\n            _self.set('isOpen', false);\n            _self.set('isLoading', false);\n          });\n        } else {\n          this.set('activeWrapper', null);\n          this.set('isOpen', true);\n        }\n      }\n    }\n  },\n\n  _itemObserver: Ember.observer('items', function () {\n    var _self = this;\n    Ember.run.scheduleOnce('afterRender', function () {\n      if (_self.get('activeWrapper')) {\n        _self.positionMenu(_self.get('activeWrapper').$());\n      }\n    });\n  }),\n\n\n  registerWrapper(component) {\n    this.set('activeWrapper', component);\n    this.positionMenu(component.$());\n  },\n\n  positionMenu(el) {\n    console.error(\"Could not use positionMenu, you will need to override this to create custom animation for the menu component\", el,  this.get('activeWrapper'));\n  }\n\n\n\n});\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/addon/components/paper-menu-container-abstract.js":"import Ember from 'ember';\nimport PaperMenuAbstract from './paper-menu-abstract';\n\n\n/**\n * The paper-menu-container-abstract is responsible for animation and positioning the menu / select /  any other\n * menu based component.\n *\n * @abstract\n */\nexport default Ember.Component.extend({\n  transitionEvents: Ember.inject.service(),\n  constants: Ember.inject.service(),\n\n  classNames: ['md-default-theme'],\n  classNameBindings: ['interaction:md-clickable'],\n\n  menuAbstract: Ember.computed(function() {\n    var container = this.nearestOfType(PaperMenuAbstract);\n    return container;\n  }),\n\n  _resizeHandler: Ember.computed(function() {\n    var _self = this;\n    return  function () {\n      _self.get('menuAbstract').registerWrapper(_self);\n    };\n  }),\n\n\n  moveComponentToBody: Ember.on('didInsertElement', function() {\n    var _self = this;\n    var dom = this.$().detach();\n    Ember.$('body').append(dom);\n\n    var menuAbstract = this.get('menuAbstract');\n\n    window.requestAnimationFrame(function () {\n      window.requestAnimationFrame(function () {\n        menuAbstract.registerWrapper(_self);\n        window.requestAnimationFrame(function () {\n          _self.$().addClass('md-active');\n          _self.set('alreadyOpen', true);\n          _self.$()[0].style[_self.get('constants').get('CSS').TRANSFORM] = '';\n        });\n      });\n    });\n\n\n    // Register resize handler.\n    Ember.$(window).on('resize',this.get('_resizeHandler'));\n\n  }),\n\n  willDestroyElement() {\n    // Destroy resize handler.\n    Ember.$(window).off('resize',this.get('_resizeHandler'));\n  },\n\n  hideWrapper() {\n    var _self = this;\n    return new Ember.RSVP.Promise(function (resolve/*, reject*/) {\n      _self.get('transitionEvents').addEndEventListener(_self.get('element'), resolve);\n      _self.$().removeClass('md-active').addClass('md-leave');\n    });\n  },\n\n  actions: {\n    toggleMenu() {\n      this.get('menuAbstract').send('toggleMenu');\n    }\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/addon/components/paper-menu-container.js":"import PaperMenuContainerAbstract from './paper-menu-container-abstract';\n\nexport default PaperMenuContainerAbstract.extend({\n  classNames: ['md-whiteframe-z2','md-open-menu-container'],\n  interaction: true\n});\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/addon/components/paper-menu-content.js":"import PaperMenuContainer from './paper-menu-container';\n\nexport default PaperMenuContainer;\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/addon/components/paper-menu-content-pane.js":"import Ember from 'ember';\nimport PaperMenuAbstract from './paper-menu-abstract';\n\nexport default Ember.Component.extend({\n  tagName: 'md-menu-content',\n\n  constants: Ember.inject.service(),\n\n  classNames: ['md-default-theme'],\n  attributeBindings: ['width'],\n  width: 4,\n\n\n  menuAbstract: Ember.computed(function() {\n    var container = this.nearestOfType(PaperMenuAbstract);\n    return container;\n  }),\n\n\n  keyDown(ev) {\n    var KeyCodes = this.get('constants').KEYCODE;\n    switch(ev.keyCode) {\n      case KeyCodes.get('ESCAPE'):\n        this.get('menuAbstract').send('toggleMenu');\n        break;\n      case KeyCodes.get('UP_ARROW'):\n        this.focusMenuItem(ev, -1);\n        break;\n      case KeyCodes.get('DOWN_ARROW'):\n        this.focusMenuItem(ev, 1);\n        break;\n    }\n  },\n\n\n  didInsertElement() {\n    var _self = this;\n    // kick off initial focus in the menu on the first element\n\n    Ember.run.later(function () {\n      var focusTarget = _self.$().find('.md-menu-focus-target');\n      if (!focusTarget.length) {\n        focusTarget = _self.$().children().eq(0).children().eq(0);\n      }\n      focusTarget.focus();\n    });\n  },\n\n  focusMenuItem(e, direction) {\n    var currentItem = Ember.$(e.target).closest('md-menu-item');\n\n    var children = this.$().children();\n    var items = Ember.$.makeArray(children);\n    var currentIndex = children.index(currentItem);\n\n    // Traverse through our elements in the specified direction (+/-1) and try to\n    // focus them until we find one that accepts focus\n    for (var i = currentIndex + direction; i >= 0 && i < items.length; i = i + direction) {\n      var focusTarget = items[i].firstElementChild || items[i];\n      var didFocus = this.attemptFocus(focusTarget);\n      if (didFocus) {\n        break;\n      }\n    }\n  },\n  attemptFocus(el) {\n    if (el && el.getAttribute('tabindex') !== -1) {\n      el.focus();\n      if (document.activeElement === el) {\n        return true;\n      } else {\n        return false;\n      }\n    }\n  },\n\n  checkClickTarget(e) {\n    var target = e.target;\n\n    // Traverse up the event until we get to the menuAbstract to see\n    // if there is a click and that the element is not disabled\n    do {\n      if (target === this.get('element')) {\n        return;\n      }\n\n      if (target.hasAttribute('action')) {\n        if (!target.hasAttribute('disabled')) {\n          this.get('menuAbstract').send('toggleMenu');\n        }\n        break;\n      }\n    } while (target = target.parentNode);\n\n  },\n\n  click(e) {\n    this.checkClickTarget(e);\n  }\n\n});\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/addon/components/paper-menu-item.js":"import Ember from 'ember';\n\nexport default Ember.Component.extend({\n  tagName: 'md-menu-item',\n\n  actions: {\n    action() {\n      this.sendAction('action', this.get('param'));\n    }\n  }\n\n});\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/addon/components/paper-menu.js":"import Ember from 'ember';\nimport PaperMenuAbstract from './paper-menu-abstract';\n\nvar MENU_EDGE_MARGIN = 8;\n\nexport default PaperMenuAbstract.extend({\n  tagName: 'md-menu',\n\n  position: 'target',\n\n  offset: '0 0',\n\n  positionMode: Ember.computed('position', function() {\n    var attachment = (this.get('position') || 'target').split(' ');\n\n    // If attachment is a single item, duplicate it for our second value.\n    // ie. 'target' -> 'target target'\n    if (attachment.length === 1) {\n      attachment.push(attachment[0]);\n    }\n\n    return {\n      left: attachment[0],\n      top: attachment[1]\n    };\n  }),\n\n  offsets: Ember.computed('offset', function() {\n    var offsets = (this.get('offset') || '0 0').split(' ').map(parseFloat);\n    if (offsets.length === 2) {\n      return {\n        left: offsets[0],\n        top: offsets[1]\n      };\n    } else if (offsets.length === 1) {\n      return {\n        top: offsets[0],\n        left: offsets[0]\n      };\n    } else {\n      throw Error('Invalid offsets specified. Please follow format <x, y> or <n>');\n    }\n  }),\n\n  positionMenu(el) {\n    // containerNode = wrapper\n    var containerNode = el[0],\n    // md-menu-content / any other child.z\n      openMenuNode = el[0].firstElementChild,\n      openMenuNodeRect = openMenuNode.getBoundingClientRect(),\n    // body\n      boundryNode = document.body,\n      boundryNodeRect = boundryNode.getBoundingClientRect();\n\n    // icon that opens the menu\n    var originNode = this.$()[0].querySelector('.md-menu-origin'),\n      originNodeRect = originNode.getBoundingClientRect();\n\n\n    var bounds = {\n      left: boundryNodeRect.left + MENU_EDGE_MARGIN,\n      top: Math.max(boundryNodeRect.top, 0) + MENU_EDGE_MARGIN,\n      bottom: Math.max(boundryNodeRect.bottom, Math.max(boundryNodeRect.top, 0) + boundryNodeRect.height) - MENU_EDGE_MARGIN,\n      right: boundryNodeRect.right - MENU_EDGE_MARGIN\n    };\n\n\n    var alignTarget, alignTargetRect, existingOffsets;\n    var positionMode = this.get('positionMode');\n\n\n\n\n    if (positionMode.top === 'target' || positionMode.left === 'target' || positionMode.left === 'target-right') {\n      // TODO: Allow centering on an arbitrary node, for now center on first menu-item's child\n      // Icon INSIDE the wrapper.\n      alignTarget = firstVisibleChild();\n      if (!alignTarget) {\n        throw Error('Error positioning menu. No visible children.');\n      }\n      alignTarget = alignTarget.querySelector('.md-menu-align-target') || alignTarget;\n      alignTargetRect = alignTarget.getBoundingClientRect();\n\n      existingOffsets = {\n        top: parseFloat(containerNode.style.top || 0),\n        left: parseFloat(containerNode.style.left || 0)\n      };\n    }\n\n\n\n    var position = {};\n    var transformOrigin = 'top ';\n\n    switch (positionMode.top) {\n      case 'target':\n        position.top = existingOffsets.top + originNodeRect.top - alignTargetRect.top;\n        break;\n      // Future support for mdMenuBar\n      // case 'top':\n      //   position.top = originNodeRect.top;\n      //   break;\n      // case 'bottom':\n      //   position.top = originNodeRect.top + originNodeRect.height;\n      //   break;\n      default:\n        throw new Error('Invalid target mode \"' + positionMode.top + '\" specified for md-menu on Y axis.');\n    }\n\n    switch (positionMode.left) {\n      case 'target':\n        position.left = existingOffsets.left + originNodeRect.left - alignTargetRect.left;\n        transformOrigin += 'left';\n        break;\n      case 'target-right':\n        position.left = originNodeRect.right - openMenuNodeRect.width + (openMenuNodeRect.right - alignTargetRect.right);\n        transformOrigin += 'right';\n        break;\n      // Future support for mdMenuBar\n      // case 'left':\n      //   position.left = originNodeRect.left;\n      //   transformOrigin += 'left';\n      //   break;\n      // case 'right':\n      //   position.left = originNodeRect.right - containerNode.offsetWidth;\n      //   transformOrigin += 'right';\n      //   break;\n      default:\n        throw new Error('Invalid target mode \"' + positionMode.left + '\" specified for md-menu on X axis.');\n    }\n\n    var offsets = this.get('offsets');\n    position.top += offsets.top;\n    position.left += offsets.left;\n\n    clamp(position);\n\n\n\n\n    el.css({\n      top: position.top + 'px',\n      left: position.left + 'px'\n    });\n\n\n\n    containerNode.style[this.get('constants').get('CSS').TRANSFORM_ORIGIN] = transformOrigin;\n\n    if (!this.get('alreadyOpen')) {\n      // Animate a scale out if we aren't just repositioning\n      /*containerNode.style[this.get('constants').get('CSS').TRANSFORM] = 'scale(' +\n       Math.min(originNodeRect.width / containerNode.offsetWidth, 1.0) + ',' +\n       Math.min(originNodeRect.height / containerNode.offsetHeight, 1.0) +\n       ')';*/\n    }\n    /**\n     * Clamps the repositioning of the menu within the confines of\n     * bounding element (often the screen/body)\n     */\n    function clamp(pos) {\n      pos.top = Math.max(Math.min(pos.top, bounds.bottom - containerNode.offsetHeight), bounds.top);\n      pos.left = Math.max(Math.min(pos.left, bounds.right - containerNode.offsetWidth), bounds.left);\n    }\n\n    /**\n     * Gets the first visible child in the openMenuNode\n     * Necessary incase menu nodes are being dynamically hidden\n     */\n    function firstVisibleChild() {\n      for (var i = 0; i < openMenuNode.children.length; ++i) {\n        if (window.getComputedStyle(openMenuNode.children[i]).display !== 'none') {\n          return openMenuNode.children[i];\n        }\n      }\n    }\n  }\n\n});\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/addon/components/paper-nav-container.js":"import Ember from 'ember';\n\nexport default Ember.Component.extend({\n  tagName: 'section',\n  attributeBindings: ['layoutAttr:layout', 'flex'],\n  layoutAttr: 'row',\n  sideBar: null\n\n});\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/addon/components/paper-optgroup.js":"import Ember from 'ember';\n\nexport default Ember.Component.extend({\n  tagName: 'md-optgroup',\n  attributeBindings: ['label']\n});\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/addon/components/paper-option.js":"import Ember from 'ember';\nimport PaperMenuAbstract from './paper-menu-abstract';\n\nimport BaseFocusable from './base-focusable';\nimport RippleMixin from '../mixins/ripple-mixin';\n\nexport default BaseFocusable.extend(RippleMixin, {\n  tagName: 'md-option',\n\n  constants: Ember.inject.service(),\n\n\n  attributeBindings: ['selected', 'isDisabled:disabled'],\n\n  focus: false,\n\n  /* RippleMixin overrides */\n  center: false,\n  dimBackground: true,\n  outline: false,\n  isMenuItem: false,\n  fullRipple: true,\n\n  isDisabled: Ember.computed('disabled', function () {\n    return this.get('disabled') ? 'disabled' : null;\n  }),\n\n\n  menuAbstract: Ember.computed(function () {\n    var container = this.nearestOfType(PaperMenuAbstract);\n    return container;\n  }),\n\n\n  click(ev) {\n    this.selectListener(ev);\n  },\n\n  keyDown (ev) {\n    if (ev.keyCode === this.get('constants').KEYCODE.get('ENTER') || ev.keyCode === this.get('constants').KEYCODE.get('SPACE')) {\n      this.selectListener(ev);\n    }\n  },\n\n\n  selectListener(ev) {\n    var selectMenu = this.get('menuAbstract'),\n      isSelected = this.get('selected');\n\n    if (this.get('disabled')) {\n      ev.stopImmediatePropagation();\n      return;\n    }\n\n\n    if (selectMenu.get('multiple')) {\n      if (isSelected) {\n        selectMenu.send('deselect', this.get('value'));\n      } else {\n        selectMenu.send('selectOption', this.get('value'));\n      }\n    } else {\n      if (!isSelected) {\n        selectMenu.send('deselectOption', this.get('value'));\n        selectMenu.send('selectOption', this.get('value'));\n      }\n    }\n    this.get('menuAbstract').send('toggleMenu');\n  },\n\n  selected: Ember.computed('menuAbstract.model', function () {\n    return this.get('menuAbstract').get('model') === this.get('value') ? 'selected' : null;\n  })\n});\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/addon/components/paper-progress-circular.js":"import Ember from 'ember';\nimport ColorMixin from 'ember-paper/mixins/color-mixin';\n\nconst BASE_DIAMETER = 48;\nconst DEFAULT_PROGRESS_SIZE = 100;\nconst DEFAULT_SCALING = 0.5;\n\nconst MODE_DETERMINATE = 'determinate',\n  MODE_INDETERMINATE = 'indeterminate';\n\n\nexport default Ember.Component.extend(ColorMixin, {\n  tagName: 'md-progress-circular',\n\n  classNames: ['md-default-theme'],\n  attributeBindings: ['value', 'mode:md-mode', 'circleStyle:style'],\n\n  mode: Ember.computed('value', function() {\n    var value = this.get('value');\n    return Ember.isPresent(value) ? MODE_DETERMINATE : MODE_INDETERMINATE;\n  }),\n\n  spinnerClass: Ember.computed('mode', function() {\n    const mode = this.get('mode');\n\n    switch (mode) {\n      case MODE_DETERMINATE:\n      case MODE_INDETERMINATE:\n        return `md-mode-${mode}`;\n      default:\n        return `ng-hide`;\n    }\n  }),\n\n  diameter: BASE_DIAMETER,\n\n  constants: Ember.inject.service(),\n  util: Ember.inject.service(),\n\n  clampedValue: Ember.computed('value', function() {\n    const value = this.get('value');\n    return Math.max(0, Math.min(value || 0, 100));\n  }),\n\n  circleStyle: Ember.computed('diameterRatio', function() {\n    return Ember.String.htmlSafe(`${this.get('constants.CSS.TRANSFORM')}: scale(${this.get('diameterRatio')})`);\n  }),\n\n  gapStyle: Ember.computed('clampedValue', function() {\n    const value = this.get('clampedValue');\n    const borderBottomColor = (value <= 50) ? 'transparent !important' : '',\n      transition = (value <= 50) ? '' : 'borderBottomColor 0.1s linear';\n\n    var style = '';\n\n    if (borderBottomColor) {\n      style = `border-bottom-color: ${borderBottomColor}; `;\n    }\n\n    if (transition) {\n      style = style + `${this.get('constants.CSS.TRANSITION')}: ${transition}`;\n    }\n\n    return Ember.String.htmlSafe(style);\n  }),\n\n  leftStyle: Ember.computed('mode', 'clampedValue', function() {\n    if (this.get('mode') !== MODE_DETERMINATE) {\n      return Ember.String.htmlSafe('');\n    }\n    const value = this.get('clampedValue');\n    const transition = (value <= 50) ? 'transform 0.1s linear' : '',\n      transform = this.get('util').supplant('rotate({0}deg)', [value <= 50 ? 135 : (((value - 50) / 50 * 180) + 135)]);\n\n    var style = '';\n\n    if (transition) {\n      style = `${this.get('constants.CSS.TRANSITION')}: ${transition}; `;\n    }\n\n    if (transform) {\n      style = style + `${this.get('constants.CSS.TRANSFORM')}: ${transform}`;\n    }\n\n    return Ember.String.htmlSafe(style);\n  }),\n\n  rightStyle: Ember.computed('mode', 'clampedValue', function() {\n    if (this.get('mode') !== MODE_DETERMINATE) {\n      return Ember.String.htmlSafe('');\n    }\n    const value = this.get('clampedValue');\n    const transition = (value >= 50) ? 'transform 0.1s linear' : '',\n      transform = this.get('util').supplant('rotate({0}deg)', [value >= 50 ? 45 : (value / 50 * 180 - 135)]);\n\n    var style = '';\n\n    if (transition) {\n      style = `${this.get('constants.CSS.TRANSITION')}: ${transition}; `;\n    }\n\n    if (transform) {\n      style = style + `${this.get('constants.CSS.TRANSFORM')}: ${transform}`;\n    }\n\n    return Ember.String.htmlSafe(style);\n  }),\n\n  diameterRatio: Ember.computed('md-diameter', function() {\n    if (!this.get('md-diameter')) {\n      return DEFAULT_SCALING;\n    }\n\n    const match = /([0-9]*)%/.exec(this.get('md-diameter'));\n    const value = Math.max(0, (match && match[1] / 100) || parseFloat(this.get('md-diameter')));\n\n    // should return ratio; DEFAULT_PROGRESS_SIZE === 100px is default size\n    return (value > 1) ? value / DEFAULT_PROGRESS_SIZE : value;\n  })\n\n});\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/addon/components/paper-progress-linear.js":"import Ember from 'ember';\nimport ColorMixin from 'ember-paper/mixins/color-mixin';\n\nfunction makeTransform(value) {\n  var scale = value / 100;\n  var translateX = (value - 100) / 2;\n  return 'translateX(' + translateX.toString() + '%) scale(' + scale.toString() + ', 1)';\n}\n\nexport default Ember.Component.extend(ColorMixin, {\n  tagName: 'md-progress-linear',\n\n  attributeBindings: ['mode:md-mode', 'buffer-value:md-buffer-value'],\n  classNames: ['md-default-theme'],\n\n  constants: Ember.inject.service(),\n\n  init() {\n    this._super(...arguments);\n    this.setupTransforms();\n  },\n\n  mode: Ember.computed('value', function() {\n    var value = this.get('value');\n    var bufferValue = this.get('buffer-value');\n\n    if (Ember.isPresent(value)) {\n      if (Ember.isPresent(bufferValue)) {\n        return 'buffer';\n      } else {\n        return 'determinate';\n      }\n    } else {\n      return 'indeterminate';\n    }\n  }),\n\n  transforms: new Array(101),\n\n  setupTransforms() {\n    for (var i = 0; i < 101; i++) {\n      this.transforms[i] = makeTransform(i);\n    }\n  },\n\n  bar1Style: Ember.computed('clampedBufferValue', function() {\n    return new Ember.Handlebars.SafeString(this.get('constants.CSS.TRANSFORM') + ': ' + this.transforms[this.get('clampedBufferValue')]);\n  }),\n\n  bar2Style: Ember.computed('clampedValue', function() {\n\n    if (this.get('mode') === 'query') {\n      return new Ember.Handlebars.SafeString('');\n    }\n\n    return new Ember.Handlebars.SafeString(this.get('constants.CSS.TRANSFORM') + ': ' + this.transforms[this.get('clampedValue')]);\n  }),\n\n  clampedValue: Ember.computed('value', function() {\n\n    var value = this.get('value');\n    if (value > 100) {\n      return 100;\n    }\n\n    if (value < 0) {\n      return 0;\n    }\n\n    return Math.ceil(value || 0);\n  }),\n\n  clampedBufferValue: Ember.computed('buffer-value', function() {\n    var value = this.get('buffer-value');\n    if (value > 100) {\n      return 100;\n    }\n\n    if (value < 0) {\n      return 0;\n    }\n\n    return Math.ceil(value || 0);\n  })\n\n});\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/addon/components/paper-radio.js":"import Ember from 'ember';\nimport BaseFocusable from './base-focusable';\nimport RippleMixin from '../mixins/ripple-mixin';\nimport ColorMixin from 'ember-paper/mixins/color-mixin';\n\nexport default BaseFocusable.extend(RippleMixin, ColorMixin, {\n  tagName: 'md-radio-button',\n  classNames: ['paper-radio', 'md-default-theme'],\n  classNameBindings: ['checked:md-checked'],\n  toggle: false,\n  selected: null,\n\n  /* RippleMixin overrides */\n  center: true,\n  dimBackground: false,\n  fitRipple: true,\n  rippleContainerSelector: '.md-container',\n\n  checked: Ember.computed('value', 'selected', function() {\n    return this.get('value') === this.get('selected');\n  }),\n\n  checkedDidChange: Ember.observer('checked', function() {\n    if (this.get('checked')) {\n      this.set('selected', this.get('value'));\n      this.sendAction('changed', this.get('value'));\n    }\n  }),\n\n  click() {\n    if (this.get('disabled')) {\n      return;\n    }\n\n    if (this.get('toggle')) {\n      this.set('selected', this.get('checked') ? null : this.get('value'));\n    } else {\n      this.set('selected', this.get('value'));\n    }\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/addon/components/paper-select-container.js":"import PaperMenuContainerAbstract from './paper-menu-container-abstract';\n\nexport default PaperMenuContainerAbstract.extend({\n  classNames: ['md-select-menu-container'],\n  interaction: true\n});\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/addon/components/paper-select-core.js":"import Ember from 'ember';\nimport PaperMenuAbstract from './paper-menu-abstract';\n\nvar SELECT_EDGE_MARGIN = 8;\n\n\nfunction clamp(min, n, max) {\n  return Math.max(min, Math.min(n, max));\n}\n\nfunction getOffsetRect(node) {\n  return node ? {\n    left: node.offsetLeft,\n    top: node.offsetTop,\n    width: node.offsetWidth,\n    height: node.offsetHeight\n  } : { left: 0, top: 0, width: 0, height: 0 };\n}\n\n\n\nexport default PaperMenuAbstract.extend({\n  tagName: 'md-select',\n  placeholder: null,\n\n  classNames: ['md-default-theme'],\n\n  attributeBindings: ['tabindex', 'readonlyAttr:readonly', 'multipleAttr:multiple'],\n  tabindex: Ember.computed('readonly', function() {\n    return this.get('readonly') ? -1 : 0;\n  }),\n  readonly: null,\n  multiple: null,\n\n  readonlyAttr: Ember.computed('readonly', function() {\n    return this.get('readonly') ? 'readonly' : null;\n  }),\n  multipleAttr: Ember.computed('multiple', function() {\n    return this.get('multiple') ? 'multiple' : null;\n  }),\n\n  preventMenuOpen: Ember.computed('disabled', function() {\n    return !!this.get('disabled');\n  }),\n\n  label: Ember.computed('model', 'itemLabelCallback', function() {\n    if (!this.get('model')) {\n      return null;\n    }\n    if (this.get('itemLabelCallback')) {\n      return this.get('itemLabelCallback').call(this, this.get('model'));\n    }\n    return this.get('model');\n  }),\n\n  click () {\n    this.send('toggleMenu');\n  },\n\n  actions: {\n    selectOption (model) {\n      this.set('model', model);\n    },\n    deselectOption () {\n      this.set('model', null);\n    }\n  },\n\n  /* @todo move to util */\n  floatingScrollbars: Ember.computed(function() {\n    var tempNode = Ember.$('<div style=\"width: 100%; z-index: -1; position: absolute; height: 35px; overflow-y: scroll\"><div style=\"height: 60;\"></div></div>');\n    Ember.$('body').append(tempNode[0]);\n    var hasFloating = (tempNode[0].offsetWidth === tempNode[0].childNodes[0].offsetWidth);\n    tempNode.remove();\n    return hasFloating;\n  }),\n\n  keyDown (e) {\n    var KeyCodes = this.get('constants').KEYCODE;\n    var allowedCodes = [\n      KeyCodes.get('SPACE'),\n      KeyCodes.get('ENTER'),\n      KeyCodes.get('UP_ARROW'),\n      KeyCodes.get('DOWN_ARROW')\n    ];\n\n    if (allowedCodes.indexOf(e.keyCode) !== -1 ) {\n      // prevent page scrolling on interaction\n      e.preventDefault();\n      this.send('toggleMenu');\n    } else {\n      if (e.keyCode <= 90 && e.keyCode >= 31) {\n        e.preventDefault();\n        /* todo. use paper-select-menu's optNodeForKeyboardSearch.\n        var node = this.optNodeForKeyboardSearch(e);\n        if (!node) return;\n        this.set('focusedNode', node || this.get('focusedNode'));\n        if (node) {\n          node.focus();\n        }*/\n      }\n    }\n  },\n\n\n\n\n  /**\n   * Select menu have other animations then \"md-menu\", so we override the positionMenu here.\n   */\n  positionMenu(element) {\n    if (!this.get('isOpen')) {\n      return;\n    }\n    var _self = this,\n      opts = {\n      target: this.$(),\n      parent: Ember.$('body'),\n      selectEl: element.find('md-select-menu'),\n      contentEl: element.find('md-content')\n    };\n\n    var containerNode = element[0],\n      targetNode = opts.target[0].firstElementChild, // target the label\n      parentNode = opts.parent[0],\n      selectNode = opts.selectEl[0],\n      contentNode = opts.contentEl[0],\n      parentRect = parentNode.getBoundingClientRect(),\n      targetRect = targetNode.getBoundingClientRect(),\n      shouldOpenAroundTarget = false,\n      bounds = {\n        left: parentRect.left + SELECT_EDGE_MARGIN,\n        top: SELECT_EDGE_MARGIN,\n        bottom: parentRect.height - SELECT_EDGE_MARGIN,\n        right: parentRect.width - SELECT_EDGE_MARGIN - (this.get('floatingScrollbars') ? 16 : 0)\n      },\n      spaceAvailable = {\n        top: targetRect.top - bounds.top,\n        left: targetRect.left - bounds.left,\n        right: bounds.right - (targetRect.left + targetRect.width),\n        bottom: bounds.bottom - (targetRect.top + targetRect.height)\n      },\n      maxWidth = parentRect.width - SELECT_EDGE_MARGIN * 2,\n      isScrollable = contentNode.scrollHeight > contentNode.offsetHeight,\n      selectedNode = selectNode.querySelector('md-option[selected]'),\n      optionNodes = selectNode.getElementsByTagName('md-option'),\n      optgroupNodes = selectNode.getElementsByTagName('md-optgroup');\n\n\n    var centeredNode;\n    // If a selected node, center around that\n    if (selectedNode) {\n      centeredNode = selectedNode;\n      // If there are option groups, center around the first option group\n    } else if (optgroupNodes.length) {\n      centeredNode = optgroupNodes[0];\n      // Otherwise, center around the first optionNode\n    } else if (optionNodes.length){\n      centeredNode = optionNodes[0];\n      // In case there are no options, center on whatever's in there... (eg progress indicator)\n    } else {\n      centeredNode = contentNode.firstElementChild || contentNode;\n    }\n\n    if (contentNode.offsetWidth > maxWidth) {\n      contentNode.style['max-width'] = maxWidth + 'px';\n    }\n    if (shouldOpenAroundTarget) {\n      contentNode.style['min-width'] = targetRect.width + 'px';\n    }\n\n    // Remove padding before we compute the position of the menu\n    if (isScrollable) {\n      selectNode.classList.add('md-overflow');\n    }\n\n    var focusedNode = centeredNode;\n    if ((focusedNode.tagName || '').toUpperCase() === 'MD-OPTGROUP') {\n      focusedNode = optionNodes[0] || contentNode.firstElementChild || contentNode;\n      centeredNode = focusedNode;\n    }\n\n    // Get the selectMenuRect *after* max-width is possibly set above\n    var selectMenuRect = selectNode.getBoundingClientRect();\n    var centeredRect = getOffsetRect(centeredNode);\n\n\n    if (centeredNode) {\n      var centeredStyle = window.getComputedStyle(centeredNode);\n      centeredRect.paddingLeft = parseInt(centeredStyle.paddingLeft, 10) || 0;\n      centeredRect.paddingRight = parseInt(centeredStyle.paddingRight, 10) || 0;\n    }\n\n\n    if (isScrollable) {\n      var scrollBuffer = contentNode.offsetHeight / 2;\n      contentNode.scrollTop = centeredRect.top + centeredRect.height / 2 - scrollBuffer;\n\n      if (spaceAvailable.top < scrollBuffer) {\n        contentNode.scrollTop = Math.min(\n          centeredRect.top,\n          contentNode.scrollTop + scrollBuffer - spaceAvailable.top\n        );\n      } else if (spaceAvailable.bottom < scrollBuffer) {\n        contentNode.scrollTop = Math.max(\n          centeredRect.top + centeredRect.height - selectMenuRect.height,\n          contentNode.scrollTop - scrollBuffer + spaceAvailable.bottom\n        );\n      }\n    }\n\n    var left, top, transformOrigin;\n    if (shouldOpenAroundTarget) {\n      left = targetRect.left;\n      top = targetRect.top + targetRect.height;\n      transformOrigin = '50% 0';\n      if (top + selectMenuRect.height > bounds.bottom) {\n        top = targetRect.top - selectMenuRect.height;\n        transformOrigin = '50% 100%';\n      }\n    } else {\n      left = (targetRect.left + centeredRect.left - centeredRect.paddingLeft) + 2;\n      top = Math.floor(targetRect.top + targetRect.height / 2 - centeredRect.height / 2 -\n          centeredRect.top + contentNode.scrollTop) + 2;\n\n\n      transformOrigin = (centeredRect.left + targetRect.width / 2) + 'px ' +\n        (centeredRect.top + centeredRect.height / 2 - contentNode.scrollTop) + 'px 0px';\n\n      containerNode.style.minWidth = targetRect.width + centeredRect.paddingLeft +\n        centeredRect.paddingRight + 'px';\n    }\n\n    // Keep left and top within the window\n    var containerRect = containerNode.getBoundingClientRect();\n    containerNode.style.left = clamp(bounds.left, left, bounds.right - containerRect.width) + 'px';\n    containerNode.style.top = clamp(bounds.top, top, bounds.bottom - containerRect.height) + 'px';\n    selectNode.style[this.get('constants').get('CSS').TRANSFORM_ORIGIN] = transformOrigin;\n\n    selectNode.style[this.get('constants').get('CSS').TRANSFORM] = 'scale(' +\n      Math.min(targetRect.width / selectMenuRect.width, 1.0) + ',' +\n      Math.min(targetRect.height / selectMenuRect.height, 1.0) +\n      ')';\n\n\n    window.requestAnimationFrame(function() {\n      element.addClass('md-active');\n      selectNode.style[_self.get('constants').get('CSS').TRANSFORM] = '';\n      if (focusedNode && !focusedNode.hasAttribute('disabled')) {\n        _self.set('focusedNode', focusedNode);\n        focusedNode.focus();\n      }\n    });\n  }\n\n\n\n});\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/addon/components/paper-select.js":"import Ember from 'ember';\nimport PaperInput from './paper-input';\n\nexport default PaperInput.extend({\n  label: Ember.computed.alias('placeholder'),\n  value: Ember.computed.alias('model'),\n  itemLabelCallback: Ember.computed.alias('item-label-callback'),\n  onOpen: Ember.computed.alias('on-open')\n});\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/addon/components/paper-select-menu.js":"import Ember from 'ember';\nimport PaperMenuAbstract from './paper-menu-abstract';\n\nvar searchStr = '';\nvar clearSearchTimeout, optNodes, optText;\nvar CLEAR_SEARCH_AFTER = 300;\n\n\n\nexport default Ember.Component.extend({\n  tagName: 'md-select-menu',\n  classNames: ['md-default-theme'],\n\n  constants: Ember.inject.service(),\n\n\n  menuAbstract: Ember.computed(function() {\n    var container = this.nearestOfType(PaperMenuAbstract);\n    return container;\n  }),\n\n  keyDown(ev) {\n    var KeyCodes = this.get('constants').KEYCODE;\n    switch(ev.keyCode) {\n      case KeyCodes.get('TAB'):\n      case KeyCodes.get('ESCAPE'):\n        this.get('menuAbstract').send('toggleMenu');\n        break;\n      case KeyCodes.get('UP_ARROW'):\n        this.focusPrevOption();\n        break;\n      case KeyCodes.get('DOWN_ARROW'):\n        this.focusNextOption();\n        break;\n      default:\n        if (ev.keyCode >= 31 && ev.keyCode <= 90) {\n          var optNode = this.optNodeForKeyboardSearch(ev);\n          this.get('menuAbstract').set('focusedNode', optNode || this.get('menuAbstract').get('focusedNode'));\n          if (optNode) {\n            optNode.focus();\n          }\n        }\n    }\n  },\n\n\n  optNodeForKeyboardSearch(e) {\n    if (clearSearchTimeout) {\n      clearTimeout(clearSearchTimeout);\n    }\n    clearSearchTimeout = setTimeout(function() {\n      clearSearchTimeout = undefined;\n      searchStr = '';\n      optText = undefined;\n      optNodes = undefined;\n    }, CLEAR_SEARCH_AFTER);\n    searchStr += String.fromCharCode(e.keyCode);\n    var search = new RegExp('^' + searchStr, 'i');\n    if (!optNodes) {\n      optNodes = this.$().find('md-option');\n      optText = new Array(optNodes.length);\n      optNodes.each(function(i, el) {\n        optText[i] = el.textContent.trim();\n      });\n    }\n    for (var i = 0; i < optText.length; ++i) {\n      if (search.test(optText[i])) {\n        return optNodes[i];\n      }\n    }\n  },\n\n\n  focusOption(direction) {\n    var optionsArray = this.$().find('md-option').toArray();\n    var index = optionsArray.indexOf(this.get('menuAbstract').get('focusedNode'));\n\n    var newOption;\n\n    do {\n      if (index === -1) {\n        // We lost the previously focused element, reset to first option\n        index = 0;\n      } else if (direction === 'next' && index < optionsArray.length - 1) {\n        index++;\n      } else if (direction === 'prev' && index > 0) {\n        index--;\n      }\n      newOption = optionsArray[index];\n      if (newOption.hasAttribute('disabled')) {\n        newOption = undefined;\n      }\n    } while (!newOption && index < optionsArray.length - 1 && index > 0);\n\n    if (newOption) {\n      newOption.focus();\n    }\n    this.get('menuAbstract').set('focusedNode', newOption);\n  },\n  focusNextOption() {\n    this.focusOption('next');\n  },\n  focusPrevOption() {\n    this.focusOption('prev');\n  }\n\n});\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/addon/components/paper-select-value.js":"import Ember from 'ember';\n\nexport default Ember.Component.extend({\n  tagName: 'md-select-value',\n  classNames: ['md-select-value'],\n  classNameBindings: ['isPlaceholder:md-select-placeholder'],\n\n  isPlaceholder: Ember.computed('value', function() {\n    return !this.get('value');\n  }),\n\n  label: Ember.computed('isPlaceholder', function() {\n    if (this.get('isPlaceholder')) {\n      return this.get('placeholder');\n    } else {\n      return this.get('value');\n    }\n  })\n\n});\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/addon/components/paper-sidenav.js":"import Ember from 'ember';\nimport PaperNavContainer from './paper-nav-container';\n\nexport default Ember.Component.extend({\n  constants: Ember.inject.service(),\n  tagName: 'md-sidenav',\n\n  'locked-open': 'gt-sm',\n  closed: true,\n  closeOnClick: true,\n\n  navContainer: Ember.computed(function () {\n    return this.nearestOfType(PaperNavContainer);\n  }),\n\n  attributeBindings: ['tabindex'],\n  classNameBindings: ['isLockedOpen:md-locked-open', 'closed:md-closed'],\n  tabindex: -1,\n\n  _init: Ember.on('init', function() {\n    var _self = this;\n\n\n    if (this.get('navContainer')) {\n      this.get('navContainer').set('sideBar', this);\n    }\n\n    this.matchMedia();\n    this.set('__resizeWindow', function () {\n      _self.matchMedia();\n    });\n  }),\n\n  _observeClosedState: Ember.observer('closed', function() {\n    if (this.get('closed')) {\n      Ember.$('body').css('overflow', 'inherit');\n    } else {\n      Ember.$('body').css('overflow', 'hidden');\n    }\n  }),\n\n  didInsertElement() {\n    Ember.$(window).on('resize', this.get('__resizeWindow'));\n  },\n  willDestroyElement() {\n    Ember.$(window).off('resize', this.get('__resizeWindow'));\n  },\n\n  matchMedia() {\n    var mediaQuery = this.get('constants').MEDIA[this.get('locked-open')];\n    this.set('isLockedOpen', window.matchMedia(mediaQuery).matches);\n    if (this.get('isLockedOpen')) {\n      this.set('closed', true);\n    }\n  },\n\n  actions: {\n    toggleMenu() {\n      if (!this.get('isLockedOpen')) {\n        this.toggleProperty('closed');\n      }\n    }\n  },\n\n  click() {\n    if (!this.get('closeOnClick') || this.get('isLockedOpen')) {\n      return;\n    }\n\n    var _self = this;\n    Ember.run.next(function() {\n      _self.set('closed', true);\n    });\n  }\n\n});\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/addon/components/paper-sidenav-toggle.js":"import Ember from 'ember';\nimport PaperNavContainer from './paper-nav-container';\n\nexport default Ember.Component.extend({\n  tagName: 'div',\n\n  navContainer: Ember.computed(function() {\n    return this.nearestOfType(PaperNavContainer);\n  }),\n\n  actions: {\n    toggleMenu: function() {\n      this.get(\"navContainer\").get('sideBar').send('toggleMenu');\n    }\n  },\n\n  didInsertElement() {\n    this._super(...arguments);\n    if (this.get('navContainer')) {\n      var lockedOpen = this.get(\"navContainer\").get('sideBar').get('locked-open');\n      if (lockedOpen) {\n        this.$().attr('hide-' + lockedOpen, true);\n      }\n    }\n  }\n\n});\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/addon/components/paper-slider.js":"import Ember from 'ember';\nimport EventsMixin from 'ember-paper/mixins/events-mixin';\nimport BaseFocusable from './base-focusable';\n\nimport ColorMixin from 'ember-paper/mixins/color-mixin';\nimport FlexMixin from 'ember-paper/mixins/flex-mixin';\n\nexport default BaseFocusable.extend(EventsMixin, FlexMixin, ColorMixin, {\n\n  tagName: 'md-slider',\n\n  attributeBindings: ['min', 'max', 'step', 'discrete:md-discrete', 'tabindex'],\n\n  classNames: ['md-default-theme'],\n  classNameBindings: ['isMinimum:md-min', 'active', 'dragging'],\n\n  constants: Ember.inject.service(),\n\n  min: 0,\n  max: 100,\n  step: 1,\n  tabindex: 0,\n\n  trackContainer: Ember.computed(function() {\n    var element = this.$()[0];\n\n    return this.$(element.querySelector('.md-track-container'));\n  }),\n\n  activeTrackStyle: Ember.computed('percent', function() {\n    var percent = this.get('percent') || 0;\n    return Ember.String.htmlSafe(\"width: \" + (percent * 100) + \"%\");\n  }),\n\n  thumbContainerStyle: Ember.computed('percent', function() {\n    var percent = this.get('percent') || 0;\n    return Ember.String.htmlSafe(\"left: \" + (percent * 100) + \"%\");\n  }),\n\n  isMinimum: Ember.computed('percent', 'min', function() {\n    return this.get('percent') === this.get('min');\n  }),\n\n  percent: Ember.computed('value', 'min', 'max', function() {\n    var min = parseInt(this.get('min'), 10);\n    var max = parseInt(this.get('max'), 10);\n\n    return (this.get('value') - min) / (max - min);\n  }),\n\n  positionToPercent(x) {\n    return Math.max(0, Math.min(1, (x - this.get('sliderDimensions.left')) / this.get('sliderDimensions.width')));\n  },\n\n  percentToValue(x) {\n    var min = parseInt(this.get('min'), 10);\n    var max = parseInt(this.get('max'), 10);\n    return (min + x * (max - min));\n  },\n\n  minMaxValidator(value) {\n    var min = parseInt(this.get('min'), 10);\n    var max = parseInt(this.get('max'), 10);\n    return Math.max(min, Math.min(max, value));\n  },\n\n  stepValidator(value) {\n    var step = parseInt(this.get('step'), 10);\n    return Math.round(value / step) * step;\n  },\n\n  active: false,\n  dragging: false,\n\n  sliderDimensions: Ember.computed(function() {\n    return this.get('trackContainer')[0].getBoundingClientRect();\n  }),\n\n  setValueFromEvent(event) {\n    //var exactVal = this.percentToValue(this.positionToPercent(event.deltaX || event.clientX));\n    var exactVal = this.percentToValue(this.positionToPercent(event.clientX || event.originalEvent.touches[0].clientX));\n    var closestVal = this.minMaxValidator(this.stepValidator(exactVal));\n\n    this.set('value', closestVal);\n  },\n\n  down(event) {\n    if (this.get('disabled')) {\n      return;\n    }\n\n    this.set('active', true);\n    this.set('dragging', true);\n    this.$().focus();\n\n    this.get('sliderDimensions');\n\n    this.setValueFromEvent(event);\n  },\n\n  up(event) {\n    if (this.get('disabled')) {\n      return;\n    }\n\n    event.stopPropagation();\n\n    this.beginPropertyChanges();\n    this.set('active', false);\n    this.set('dragging', false);\n    this.endPropertyChanges();\n  },\n\n  move(event) {\n    if (this.get('disabled') || !this.get('dragging')) {\n      return;\n    }\n\n    this.setValueFromEvent(event);\n\n  },\n\n  keyDown(event) {\n    if (this.get('disabled')) {\n      return;\n    }\n\n    var changeAmount, newValue;\n\n    if (event.keyCode === this.get('constants.KEYCODE.LEFT_ARROW')) {\n      changeAmount = parseInt(this.get('step')) * -1;\n    } else if (event.keyCode === this.get('constants.KEYCODE.RIGHT_ARROW')) {\n      changeAmount = parseInt(this.get('step'));\n    }\n\n    if (changeAmount) {\n      if (event.metaKey || event.ctrlKey || event.altKey) {\n        changeAmount *= 4;\n      }\n\n      newValue = this.get('value') + changeAmount;\n\n      this.set('value', this.minMaxValidator(newValue));\n\n      event.preventDefault();\n      event.stopPropagation();\n    }\n  }\n\n});\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/addon/components/paper-subheader.js":"import Ember from 'ember';\n\nexport default Ember.Component.extend({\n  tagName: 'h2',\n  classNames: ['md-subheader']\n});\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/addon/components/paper-switch.js":"import Ember from 'ember';\nimport BaseFocusable from './base-focusable';\nimport RippleMixin from 'ember-paper/mixins/ripple-mixin';\nimport ProxiableMixin from 'ember-paper/mixins/proxiable-mixin';\nimport ColorMixin from 'ember-paper/mixins/color-mixin';\n/* globals Hammer */\n\nexport default BaseFocusable.extend(RippleMixin, ProxiableMixin, ColorMixin, {\n  tagName: 'md-switch',\n  classNames: ['paper-switch', 'md-default-theme'],\n  classNameBindings: ['checked:md-checked', 'dragging:md-dragging'],\n  toggle: true,\n\n  center: true,\n  dimBackground: false,\n  fitRipple: true,\n  rippleContainerSelector: '.md-thumb',\n\n  checked: false,\n  disabled: false,\n\n  dragging: false,\n  dragAmount: null,\n  switchWidth: null,\n\n  onDidInsertElement: Ember.on('didInsertElement', function() {\n    // Don't set up anything if the switch is disabled\n    if (this.get('disabled')) { return; }\n\n    this._super();\n\n    this.set('switchWidth', this.$('.md-bar').width());\n\n    // Enable dragging the switch\n    var element = this.get('element')[0] || this.get('element');\n    var thumbElement = element.getElementsByClassName('md-thumb-container')[0];\n    var thumbElementHammer = new Hammer(thumbElement);\n    this.thumbElementHammer = thumbElementHammer;\n    thumbElementHammer.get('pan').set({ threshold: 1 });\n    thumbElementHammer.on('panstart', Ember.run.bind(this, this._dragStart));\n    thumbElementHammer.on('panmove', Ember.run.bind(this, this._drag));\n    thumbElementHammer.on('panend', Ember.run.bind(this, this._dragEnd));\n\n    // Allow the switch to be clicked to toggle the value\n    var switchHammer = new Hammer(element);\n    this.switchHammer = switchHammer;\n    switchHammer.on('tap', Ember.run.bind(this, this._dragEnd));\n  }),\n\n  disabledDidChange: Ember.observer('disabled', function() {\n    this.onDidInsertElement();\n  }),\n\n  willDestroyElement() {\n    this._super(...arguments);\n\n    if (this.switchHammer) {\n      this.switchHammer.destroy();\n    }\n    if (this.thumbElementHammer) {\n      this.switchHammer.destroy();\n    }\n  },\n\n  _dragStart() {\n    this.set('dragging', true);\n  },\n\n  _drag(event) {\n    if (this.get('disabled')) { return; }\n\n    // Get the amount amount the switch has been dragged\n    var percent = event.deltaX / this.get('switchWidth');\n    percent = this.get('checked') ? 1 + percent : percent;\n    this.set('dragAmount', percent);\n\n    // Make sure that the switch isn't moving past the edges\n    var translate = Math.max(0, Math.min(1, percent));\n    var transformProp = 'translate3d(' + (100 * translate) + '%, 0, 0)';\n    this.$('.md-thumb-container').css('transform', transformProp);\n    this.$('.md-thumb-container').css('-webkit-transform', transformProp);\n  },\n\n  _dragEnd() {\n    if (this.get('disabled')) { return; }\n\n    if ((!this.get('dragging')) ||\n         (this.get('checked') && this.get('dragAmount') < 0.5) ||\n         (!this.get('checked') && this.get('dragAmount') > 0.5)) {\n      this.toggleProperty('checked');\n    }\n\n    // Cleanup\n    this.$('.md-thumb-container').removeAttr('style');\n    this.set('dragging', false);\n    this.set('dragAmount', null);\n  },\n\n  processProxy() {\n    this.toggleProperty('checked');\n  },\n\n  click() {\n    return false;\n  }\n\n});\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/addon/components/paper-toolbar.js":"import Ember from 'ember';\nimport ColorMixin from 'ember-paper/mixins/color-mixin';\n\nexport default Ember.Component.extend(ColorMixin, {\n  tagName: 'md-toolbar',\n  classNames: ['md-default-theme']\n});\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/addon/mixins/color-mixin.js":"import Ember from 'ember';\n\nexport default Ember.Mixin.create({\n  classNameBindings: ['warn:md-warn', 'accent:md-accent', 'primary:md-primary']\n});\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/addon/mixins/events-mixin.js":"import Ember from 'ember';\n\nexport default Ember.Mixin.create({\n  touchStart(e) {\n    return this.down(e);\n  },\n  mouseDown(e) {\n    this.down(e);\n  },\n  touchEnd(e) {\n    return this.up(e);\n  },\n  mouseUp(e) {\n    return this.up(e);\n  },\n  touchCancel(e) {\n    return this.up(e);\n  },\n  mouseLeave(e) {\n    return this.up(e);\n  },\n  up: Ember.K,\n  down: Ember.K,\n  contextMenu: Ember.K,\n\n  /*\n   * Move events\n   */\n\n  mouseMove: function(e) {\n    return this.move(e);\n  },\n\n  touchMove: function(e) {\n    return this.move(e);\n  },\n\n  pointerMove: function(e) {\n    return this.move(e);\n  },\n\n  move: Ember.K\n});\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/addon/mixins/flex-mixin.js":"import Ember from 'ember';\n\n/**\n * Adds bindings to flex attributes\n * - flex=true|false\n * - flex-layout=column|row\n */\nexport default Ember.Mixin.create({\n  attributeBindings: [\n    'flex',\n    'flex-layout:layout',\n    // Allow responsive layout definition ( see layout.scss: layout-for-name ):\n    'layout-sm',\n    'layout-gt-sm',\n    'layout-md',\n    'layout-gt-md',\n    'layout-lg',\n    'layout-gt-lg'\n  ]\n});\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/addon/mixins/hasblock-mixin.js":"import Ember from 'ember';\n\n/**\n * This mixin add support for hasBlock for Ember < 1.13.0\n *\n * @todo Remove in Ember 2.0\n * See also https://github.com/emberjs/ember.js/pull/11313\n */\nexport default Ember.Mixin.create({\n  hasBlock: Ember.computed(function() {\n    if (typeof this._super.hasBlock === 'undefined') {\n      return !!this.get('template');\n    }\n    return this.hasBlock;\n  })\n});\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/addon/mixins/proxiable-mixin.js":"import Ember from 'ember';\nimport ProxyMixin from './proxy-mixin';\n\nexport default Ember.Mixin.create({\n  init(){\n    this._super(...arguments);\n    Ember.run(()=>{\n        Ember.run.scheduleOnce('afterRender', this, 'registerProxy');\n    });\n  },\n  registerProxy(){\n    let proxy = this.nearestOfType(ProxyMixin);\n    if (proxy) {\n      proxy.register(this);\n    }\n  },\n\n  processProxy: null\n});\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/addon/mixins/proxy-mixin.js":"import Ember from 'ember';\n\nexport default Ember.Mixin.create({\n  proxiedComponents: Ember.computed(function() {\n    return Ember.A();\n  }),\n  register(component) {\n    if (!component.get('skipProxy')) {\n      this.get('proxiedComponents').addObject(component);\n    }\n  },\n  unregister(component) {\n    this.get('proxiedComponents').removeObject(component);\n  },\n  isProxiedComponent(component) {\n    return this.get('proxiedComponents').contains(component);\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/addon/mixins/ripple-mixin.js":"import Ember from 'ember';\n/* global Hammer */\n/* global propagating */\n\nexport default Ember.Mixin.create({\n  mousedown: true,\n  hover: true,\n  focus: true,\n  center: false,\n  mousedownPauseTime: 150,\n  dimBackground: false,\n  outline: false,\n  fullRipple: true,\n  isMenuItem: false,\n  fitRipple: false,\n\n  isActive: false,\n  isHeld: false,\n  counter: 0,\n\n  ripples: [],\n  rippleStates: [],\n\n  rippleContainerSelector: '',\n\n  didInsertElement() {\n    this._super(...arguments);\n    if (!this.get('noink')) {\n      this.element = this.$();\n      this.colorElement = this.$();\n      this.node = this.element[0];\n      this.hammertime = propagating(new Hammer(this.node));\n      this.color = this.parseColor(this.element.attr('md-ink-ripple')) || this.parseColor(window.getComputedStyle(this.colorElement[0]).color || 'rgb(0, 0, 0)');\n      if (this.get('mousedown')) {\n        this.hammertime.on('hammer.input', Ember.run.bind(this, this.onInput));\n      }\n    }\n  },\n\n  willDestroyElement() {\n    this._super(...arguments);\n    if (this.rippleContainer) {\n      this.rippleContainer.remove();\n    }\n    if (this.hammertime) {\n      this.hammertime.destroy();\n    }\n  },\n\n  propagateRipple: false,\n  onInput(ev) {\n    var ripple, index;\n    if (ev.eventType === Hammer.INPUT_START && ev.isFirst && !this.get('disabled')) {\n      ripple = this.createRipple(ev.center.x, ev.center.y);\n      this.isHeld = true;\n    } else if (ev.eventType === Hammer.INPUT_END && ev.isFinal) {\n      this.isHeld = false;\n      index = this.ripples.length - 1;\n      ripple = this.ripples[index];\n      Ember.run.later(this,function(){\n        this.updateElement(ripple);\n      }, 0);\n    }\n    if (!this.get('propagateRipple')) {\n      ev.stopPropagation();\n    }\n  },\n  /**\n  * Gets the current ripple container\n  * If there is no ripple container, it creates one and returns it\n  *\n  * @returns {angular.element} ripple container element\n  */\n  getRippleContainer() {\n    if (this.rippleContainer){\n      return this.rippleContainer;\n    }\n    this.rippleContainer = Ember.$('<div class=\"md-ripple-container\">');\n    this.$(this.get('rippleContainerSelector')).append(this.rippleContainer);\n    return this.rippleContainer;\n  },\n  /**\n  * Creates the ripple element with the provided css\n  *\n  * @param {object} css properties to be applied\n  *\n  * @returns {angular.element} the generated ripple element\n  */\n  getRippleElement(css) {\n    var elem = Ember.$('<div class=\"md-ripple\" data-counter=\"' + this.counter++ + '\">');\n    this.ripples.unshift(elem);\n    this.rippleStates.unshift({ animating: true });\n    this.rippleContainer.append(elem);\n    if(css){\n      elem.css(css);\n    }\n    return elem;\n  },\n  /**\n  * Calculate the ripple size\n  *\n  * @returns {number} calculated ripple diameter\n  */\n  getRippleSize(left, top) {\n    var width = this.rippleContainer.prop('offsetWidth'),\n        height = this.rippleContainer.prop('offsetHeight'),\n        multiplier, size, rect;\n    if (this.get('isMenuItem')) {\n      size = Math.sqrt(Math.pow(width, 2) + Math.pow(height, 2));\n    } else if (this.get('outline')) {\n      rect = this.node.getBoundingClientRect();\n      left -= rect.left;\n      top -= rect.top;\n      width = Math.max(left, width - left);\n      height = Math.max(top, height - top);\n      size = 2 * Math.sqrt(Math.pow(width, 2) + Math.pow(height, 2));\n    } else {\n      multiplier = this.get('fullRipple') ? 1.1 : 0.8;\n      size = Math.sqrt(Math.pow(width, 2) + Math.pow(height, 2)) * multiplier;\n      if (this.get('fitRipple')) {\n        size = Math.min(height, width, size);\n      }\n    }\n    return size;\n  },\n  parseColor(color) {\n    if (!color) { return; }\n    if (color.indexOf('rgba') === 0) { return color.replace(/\\d?\\.?\\d*\\s*\\)\\s*$/, '0.1)'); }\n    if (color.indexOf('rgb')  === 0) { return rgbToRGBA(color); }\n    if (color.indexOf('#')    === 0) { return hexToRGBA(color); }\n\n    /**\n     * Converts a hex value to an rgba string\n     *\n     * @param {string} hex value (3 or 6 digits) to be converted\n     *\n     * @returns {string} rgba color with 0.1 alpha\n     */\n    function hexToRGBA(color) {\n      var hex = color.charAt(0) === '#' ? color.substr(1) : color,\n        dig = hex.length / 3,\n        red = hex.substr(0, dig),\n        grn = hex.substr(dig, dig),\n        blu = hex.substr(dig * 2);\n      if (dig === 1) {\n        red += red;\n        grn += grn;\n        blu += blu;\n      }\n      return 'rgba(' + parseInt(red, 16) + ',' + parseInt(grn, 16) + ',' + parseInt(blu, 16) + ',0.1)';\n    }\n\n    /**\n     * Converts rgb value to rgba string\n     *\n     * @param {string} rgb color string\n     *\n     * @returns {string} rgba color with 0.1 alpha\n     */\n    function rgbToRGBA(color) {\n      return color.replace(')', ', 0.1)').replace('(', 'a(');\n    }\n\n  },\n  /**\n  * Creates a ripple at the provided coordinates\n  *\n  * @param {number} left cursor position\n  * @param {number} top cursor position\n  *\n  * @returns {angular.element} the generated ripple element\n  */\n  createRipple(left, top) {\n    var color = this.color = this.parseColor(this.element.attr('md-ink-ripple')) || this.parseColor(window.getComputedStyle(this.colorElement[0]).color || 'rgb(0, 0, 0)');\n\n    var container = this.getRippleContainer(),\n      size = this.getRippleSize(left, top),\n      css = this.getRippleCss(size, left, top),\n      elem = this.getRippleElement(css),\n      index = this.ripples.indexOf(elem),\n      state = this.rippleStates[index] || {};\n\n    this.rippleSize = size;\n\n    state.animating = true;\n\n    Ember.run.later(this, function() {\n      if (this.get('dimBackground')) {\n        container.css({ backgroundColor: color });\n      }\n      elem.addClass('md-ripple-placed md-ripple-scaled');\n      if (this.get('outline')) {\n        elem.css({\n          borderWidth: (size * 0.5) + 'px',\n          marginLeft: (size * -0.5) + 'px',\n          marginTop: (size * -0.5) + 'px'\n        });\n      } else {\n        elem.css({ left: '50%', top: '50%' });\n      }\n      this.updateElement(elem);\n      Ember.run.later(this,function () {\n        state.animating = false;\n        this.updateElement(elem);\n      }, (this.get('outline') ? 450 : 225));\n    }, 0);\n\n    return elem;\n  },\n  removeElement(elem, wait) {\n    var ripples = this.ripples;\n    ripples.splice(ripples.indexOf(elem), 1);\n    if (ripples.length === 0 && this.rippleContainer) {\n      this.rippleContainer.css({ backgroundColor: '' });\n    }\n    Ember.run.later(this,function(){\n      elem.remove();\n    }, wait);\n  },\n  updateElement(elem) {\n    var index = this.ripples.indexOf(elem),\n    state = this.rippleStates[index] || {},\n    elemIsActive = this.ripples.length > 1 ? false : this.isActive,\n    elemIsHeld   = this.ripples.length > 1 ? false : this.isHeld;\n    if (elemIsActive || state.animating || elemIsHeld) {\n      elem.addClass('md-ripple-visible');\n    } else if (elem) {\n      elem.removeClass('md-ripple-visible');\n      if (this.get('outline')) {\n        elem.css({\n          width: this.rippleSize + 'px',\n          height: this.rippleSize + 'px',\n          marginLeft: (this.rippleSize * -1) + 'px',\n          marginTop: (this.rippleSize * -1) + 'px'\n        });\n      }\n      this.removeElement(elem, this.get('outline') ? 450 : 650);\n    }\n  },\n  /**\n  * Generates the ripple css\n  *\n  * @param {number} the diameter of the ripple\n  * @param {number} the left cursor offset\n  * @param {number} the top cursor offset\n  *\n  * @returns {{backgroundColor: *, width: string, height: string, marginLeft: string, marginTop: string}}\n  */\n  getRippleCss(size, left, top) {\n    var rect,\n    css = {\n      backgroundColor: rgbaToRGB(this.color),\n      borderColor: rgbaToRGB(this.color),\n      width: size + 'px',\n      height: size + 'px'\n    };\n\n    if (this.get('outline')) {\n      css.width = 0;\n      css.height = 0;\n    } else {\n      css.marginLeft = css.marginTop = (size * -0.5) + 'px';\n    }\n\n    if (this.get('center')) {\n      css.left = css.top = '50%';\n    } else {\n      rect = this.node.getBoundingClientRect();\n      css.left = Math.round((left - rect.left) / this.rippleContainer.prop('offsetWidth') * 100) + '%';\n      css.top = Math.round((top - rect.top) / this.rippleContainer.prop('offsetHeight') * 100) + '%';\n    }\n\n    return css;\n\n    /**\n    * Converts rgba string to rgb, removing the alpha value\n    *\n    * @param {string} rgba color\n    *\n    * @returns {string} rgb color\n    */\n    function rgbaToRGB(color) {\n      return color.replace('rgba', 'rgb').replace(/,[^\\)\\,]+\\)/, ')');\n    }\n  }\n\n});\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/addon/utils/grid-layout.js":"var defaultAnimator = GridTileAnimator;\n\n/**\n * Publish layout function\n */\nfunction GridLayout(colCount, tileSpans) {\n  var self, layoutInfo, gridStyles, layoutTime, mapTime, reflowTime;\n\n  layoutInfo = calculateGridFor(colCount, tileSpans);\n\n  return self = {\n\n    /**\n     * An array of objects describing each tile's position in the grid.\n     */\n    layoutInfo: function() {\n      return layoutInfo;\n    },\n\n    /**\n     * Maps grid positioning to an element and a set of styles using the\n     * provided updateFn.\n     */\n    map: function(updateFn) {\n      var info = self.layoutInfo();\n      gridStyles = updateFn(info.positioning, info.rowCount);\n\n      return self;\n    },\n\n    /**\n     * Default animator simply sets the element.css( <styles> ). An alternate\n     * animator can be provided as an argument. The function has the following\n     * signature:\n     *\n     *    function({grid: {element: JQLite, style: Object}, tiles: Array<{element: JQLite, style: Object}>)\n         */\n    reflow: function(animatorFn) {\n      var animator = animatorFn || defaultAnimator;\n      animator(gridStyles.grid, gridStyles.tiles);\n      return self;\n    },\n\n    /**\n     * Timing for the most recent layout run.\n     */\n    performance: function() {\n      return {\n        tileCount: tileSpans.length,\n        layoutTime: layoutTime,\n        mapTime: mapTime,\n        reflowTime: reflowTime,\n        totalTime: layoutTime + mapTime + reflowTime\n      };\n    }\n  };\n}\n\n/**\n * Default Gridlist animator simple sets the css for each element;\n * NOTE: any transitions effects must be manually set in the CSS.\n * e.g.\n *\n *  md-grid-tile {\n   *    transition: all 700ms ease-out 50ms;\n   *  }\n *\n */\nfunction GridTileAnimator(grid, tiles) {\n  grid.element.css(grid.style);\n  tiles.forEach(function(t) {\n    t.element.css(t.style);\n  });\n}\n\n/**\n * Calculates the positions of tiles.\n *\n * The algorithm works as follows:\n *    An Array<Number> with length colCount (spaceTracker) keeps track of\n *    available tiling positions, where elements of value 0 represents an\n *    empty position. Space for a tile is reserved by finding a sequence of\n *    0s with length <= than the tile's colspan. When such a space has been\n *    found, the occupied tile positions are incremented by the tile's\n *    rowspan value, as these positions have become unavailable for that\n *    many rows.\n *\n *    If the end of a row has been reached without finding space for the\n *    tile, spaceTracker's elements are each decremented by 1 to a minimum\n *    of 0. Rows are searched in this fashion until space is found.\n */\nfunction calculateGridFor(colCount, tileSpans) {\n  var curCol = 0,\n    curRow = 0,\n    spaceTracker = newSpaceTracker();\n\n  return {\n    positioning: tileSpans.map(function(spans, i) {\n      return {\n        spans: spans,\n        position: reserveSpace(spans, i)\n      };\n    }),\n    rowCount: curRow + Math.max.apply(Math, spaceTracker)\n  };\n\n  function reserveSpace(spans, i) {\n    if (spans.col > colCount) {\n      throw 'md-grid-list: Tile at position ' + i + ' has a colspan ' +\n      '(' + spans.col + ') that exceeds the column count ' +\n      '(' + colCount + ')';\n    }\n\n    var start = 0,\n      end = 0;\n\n    // TODO(shyndman): This loop isn't strictly necessary if you can\n    // determine the minimum number of rows before a space opens up. To do\n    // this, recognize that you've iterated across an entire row looking for\n    // space, and if so fast-forward by the minimum rowSpan count. Repeat\n    // until the required space opens up.\n    while (end - start < spans.col) {\n      if (curCol >= colCount) {\n        nextRow();\n        continue;\n      }\n\n      start = spaceTracker.indexOf(0, curCol);\n      if (start === -1 || (end = findEnd(start + 1)) === -1) {\n        start = end = 0;\n        nextRow();\n        continue;\n      }\n\n      curCol = end + 1;\n    }\n\n    adjustRow(start, spans.col, spans.row);\n    curCol = start + spans.col;\n\n    return {\n      col: start,\n      row: curRow\n    };\n  }\n\n  function nextRow() {\n    curCol = 0;\n    curRow++;\n    adjustRow(0, colCount, -1); // Decrement row spans by one\n  }\n\n  function adjustRow(from, cols, by) {\n    for (var i = from; i < from + cols; i++) {\n      spaceTracker[i] = Math.max(spaceTracker[i] + by, 0);\n    }\n  }\n\n  function findEnd(start) {\n    var i;\n    for (i = start; i < spaceTracker.length; i++) {\n      if (spaceTracker[i] !== 0) {\n        return i;\n      }\n    }\n\n    if (i === spaceTracker.length) {\n      return i;\n    }\n  }\n\n  function newSpaceTracker() {\n    var tracker = [];\n    for (var i = 0; i < colCount; i++) {\n      tracker.push(0);\n    }\n    return tracker;\n  }\n}\n\nexport default GridLayout;\n\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/addon/utils/promise-proxies.js":"import Ember from 'ember';\n\nvar Promise = Ember.RSVP.Promise;\n\n// See http://emberjs.com/api/data/classes/DS.PromiseArray.html\nvar PromiseArray = Ember.ArrayProxy.extend(Ember.PromiseProxyMixin);\n// See http://emberjs.com/api/data/classes/DS.PromiseObject.html\nvar PromiseObject = Ember.ObjectProxy.extend(Ember.PromiseProxyMixin);\n\nvar promiseObject = function(promise, label) {\n  return PromiseObject.create({\n    promise: Promise.resolve(promise, label)\n  });\n};\n\nvar promiseArray = function(promise, label) {\n  return PromiseArray.create({\n    promise: Promise.resolve(promise, label)\n  });\n};\n\nexport {\n  PromiseArray,\n  PromiseObject,\n  promiseArray,\n  promiseObject\n};\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/app/components/base-focusable.js":"import BaseFocusable from 'ember-paper/components/base-focusable';\n\nexport default BaseFocusable;\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/app/components/paper-autocomplete-highlight.js":"export { default } from 'ember-paper/components/paper-autocomplete-highlight';","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/app/components/paper-autocomplete-item.js":"export { default } from 'ember-paper/components/paper-autocomplete-item';\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/app/components/paper-autocomplete.js":"export { default } from 'ember-paper/components/paper-autocomplete';","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/app/components/paper-autocomplete-list.js":"export { default } from 'ember-paper/components/paper-autocomplete-list';","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/app/components/paper-backdrop.js":"import PaperBackdrop from 'ember-paper/components/paper-backdrop';\n\nexport default PaperBackdrop;\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/app/components/paper-button.js":"import PaperButton from 'ember-paper/components/paper-button';\n\nexport default PaperButton;\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/app/components/paper-card-content.js":"import PaperCardContent from 'ember-paper/components/paper-card-content';\n\nexport default PaperCardContent;\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/app/components/paper-card-footer.js":"import PaperCardFooter from 'ember-paper/components/paper-card-footer';\n\nexport default PaperCardFooter;\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/app/components/paper-card.js":"import PaperCard from 'ember-paper/components/paper-card';\n\nexport default PaperCard;\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/app/components/paper-card-title.js":"import PaperCardTitle from 'ember-paper/components/paper-card-title';\n\nexport default PaperCardTitle;\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/app/components/paper-card-title-media.js":"import PaperCardTitleMedia from 'ember-paper/components/paper-card-title-media';\n\nexport default PaperCardTitleMedia;\n\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/app/components/paper-card-title-text.js":"import PaperCardTitleText from 'ember-paper/components/paper-card-title-text';\n\nexport default PaperCardTitleText;\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/app/components/paper-checkbox.js":"import PaperCheckbox from 'ember-paper/components/paper-checkbox';\n\nexport default PaperCheckbox;\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/app/components/paper-content.js":"import PaperContent from 'ember-paper/components/paper-content';\n\nexport default PaperContent;\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/app/components/paper-divider.js":"import PaperDivider from 'ember-paper/components/paper-divider';\n\nexport default PaperDivider;\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/app/components/paper-grid-list.js":"export { default } from 'ember-paper/components/paper-grid-list';","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/app/components/paper-grid-tile-footer.js":"export { default } from 'ember-paper/components/paper-grid-tile-footer';","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/app/components/paper-grid-tile.js":"export { default } from 'ember-paper/components/paper-grid-tile';","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/app/components/paper-icon.js":"import PaperIcon from 'ember-paper/components/paper-icon';\n\nexport default PaperIcon;\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/app/components/paper-input.js":"import PaperInput from 'ember-paper/components/paper-input';\n\nexport default PaperInput;\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/app/components/paper-item.js":"import PaperItem from 'ember-paper/components/paper-item';\n\nexport default PaperItem;\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/app/components/paper-list.js":"import PaperList from 'ember-paper/components/paper-list';\n\nexport default PaperList;\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/app/components/paper-menu-container.js":"export { default } from 'ember-paper/components/paper-menu-container';\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/app/components/paper-menu-container-wrap.js":"export { default } from 'ember-paper/components/paper-menu-container-wrap';\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/app/components/paper-menu-content.js":"export { default } from 'ember-paper/components/paper-menu-content';","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/app/components/paper-menu-content-pane.js":"export { default } from 'ember-paper/components/paper-menu-content-pane';\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/app/components/paper-menu-item.js":"export { default } from 'ember-paper/components/paper-menu-item';","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/app/components/paper-menu.js":"export { default } from 'ember-paper/components/paper-menu';","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/app/components/paper-nav-container.js":"export { default } from 'ember-paper/components/paper-nav-container';","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/app/components/paper-optgroup.js":"export { default } from 'ember-paper/components/paper-optgroup';","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/app/components/paper-option.js":"import PaperOption from 'ember-paper/components/paper-option';\nexport default PaperOption;\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/app/components/paper-progress-circular.js":"export { default } from 'ember-paper/components/paper-progress-circular';\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/app/components/paper-progress-linear.js":"export { default } from 'ember-paper/components/paper-progress-linear';","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/app/components/paper-radio.js":"import PaperRadio from 'ember-paper/components/paper-radio';\n\nexport default PaperRadio;\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/app/components/paper-select-container.js":"export { default } from 'ember-paper/components/paper-select-container';\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/app/components/paper-select-core.js":"import PaperSelectCore from 'ember-paper/components/paper-select-core';\nexport default PaperSelectCore;\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/app/components/paper-select.js":"import PaperSelect from 'ember-paper/components/paper-select';\nexport default PaperSelect;\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/app/components/paper-select-menu.js":"export { default } from 'ember-paper/components/paper-select-menu';","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/app/components/paper-select-value.js":"export { default } from 'ember-paper/components/paper-select-value';","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/app/components/paper-sidenav.js":"import PaperSidenav from 'ember-paper/components/paper-sidenav';\n\nexport default PaperSidenav;\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/app/components/paper-sidenav-toggle.js":"import PaperSidenavToggle from 'ember-paper/components/paper-sidenav-toggle';\n\nexport default PaperSidenavToggle;\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/app/components/paper-slider.js":"import paperSlider from 'ember-paper/components/paper-slider';\n\nexport default paperSlider;\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/app/components/paper-subheader.js":"import PaperSubHeader from 'ember-paper/components/paper-subheader';\n\nexport default PaperSubHeader;\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/app/components/paper-switch.js":"import PaperSwitch from 'ember-paper/components/paper-switch';\n\nexport default PaperSwitch;\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/app/components/paper-toolbar.js":"import PaperToolbar from 'ember-paper/components/paper-toolbar';\n\nexport default PaperToolbar;\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/app/services/constants.js":"import Ember from 'ember';\n\nexport default Ember.Service.extend({\n\n  sniffer: Ember.inject.service('sniffer'),\n\n  webkit: Ember.computed(function() {\n    return /webkit/i.test(this.get('sniffer.vendorPrefix'));\n  }),\n\n  vendorProperty(name) {\n    var prefix = this.get('sniffer.vendorPrefix').toLowerCase();\n    return this.get('webkit') ? `-webkit-${name.charAt(0)}${name.substring(1)}` : name;\n  },\n\n  CSS: Ember.computed('webkit', function() {\n    var webkit = this.get('webkit');\n    return {\n      /* Constants */\n      TRANSITIONEND:  'transitionend' + (webkit ? ' webkitTransitionEnd'  : ''),\n      ANIMATIONEND:   'animationend'  + (webkit ? ' webkitAnimationEnd'   : ''),\n\n      TRANSFORM:              this.vendorProperty('transform'),\n      TRANSFORM_ORIGIN:       this.vendorProperty('transformOrigin'),\n      TRANSITION:             this.vendorProperty('transition'),\n      TRANSITION_DURATION:    this.vendorProperty('transitionDuration'),\n      ANIMATION_PLAY_STATE:   this.vendorProperty('animationPlayState'),\n      ANIMATION_DURATION:     this.vendorProperty('animationDuration'),\n      ANIMATION_NAME:         this.vendorProperty('animationName'),\n      ANIMATION_TIMING:       this.vendorProperty('animationTimingFunction'),\n      ANIMATION_DIRECTION:    this.vendorProperty('animationDirection')\n    };\n  }),\n\n  KEYCODE: Ember.Object.create({\n    ENTER:          13,\n    ESCAPE:         27,\n    SPACE:          32,\n    LEFT_ARROW:     37,\n    UP_ARROW:       38,\n    RIGHT_ARROW:    39,\n    DOWN_ARROW:     40,\n    TAB:            9\n  }),\n\n  MEDIA: {\n    'sm': '(max-width: 599px)',\n    'gt-sm': '(min-width: 600px)',\n    'md': '(min-width: 600px) and (max-width: 959px)',\n    'gt-md': '(min-width: 960px)',\n    'lg': '(min-width: 960px) and (max-width: 1199px)',\n    'gt-lg': '(min-width: 1200px)'\n  },\n  MEDIA_PRIORITY: [\n    'gt-lg',\n    'lg',\n    'gt-md',\n    'md',\n    'gt-sm',\n    'sm'\n  ]\n});\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/app/services/sniffer.js":"import Ember from 'ember';\n\nvar isString = function(value) {\n  return typeof value === 'string';\n};\n\nvar lowercase = function(string) {\n  return isString(string) ? string.toLowerCase() : string;\n};\n\nvar toInt = function(str) {\n  return parseInt(str, 10);\n};\n\n\nexport default Ember.Service.extend({\n  vendorPrefix: '',\n  transitions: false,\n  animations: false,\n  document: document,\n  window: window,\n\n  android: Ember.computed('', function() {\n    return toInt((/android (\\d+)/.exec(lowercase((this.get('window').navigator || {}).userAgent)) || [])[1]);\n  }),\n\n  init() {\n    this._super(...arguments);\n\n    var bodyStyle = this.get('document').body && this.get('document').body.style;\n    var vendorPrefix;\n    var vendorRegex = /^(Moz|webkit|ms)(?=[A-Z])/;\n\n    var transitions = false;\n    var animations = false;\n    var match;\n\n    if (bodyStyle) {\n      for (var prop in bodyStyle) {\n        if (match = vendorRegex.exec(prop)) {\n          vendorPrefix = match[0];\n          vendorPrefix = vendorPrefix.substr(0, 1).toUpperCase() + vendorPrefix.substr(1);\n          break;\n        }\n      }\n\n      if (!vendorPrefix) {\n        vendorPrefix = ('WebkitOpacity' in bodyStyle) && 'webkit';\n      }\n\n      transitions = !!(('transition' in bodyStyle) || (vendorPrefix + 'Transition' in bodyStyle));\n      animations = !!(('animation' in bodyStyle) || (vendorPrefix + 'Animation' in bodyStyle));\n\n      if (this.get('android') && (!transitions || !animations)) {\n        transitions = isString(bodyStyle.webkitTransition);\n        animations = isString(bodyStyle.webkitAnimation);\n      }\n\n    }\n\n    this.set('transitions', transitions);\n    this.set('animations', animations);\n\n    this.set('vendorPrefix', vendorPrefix);\n  }\n\n});\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/app/services/util.js":"import Ember from 'ember';\n\n/* global jQuery */\n\nvar Util = Ember.Service.extend({\n\n  // Disables scroll around the passed element.\n  disableScrollAround: function (element) {\n    var util = this,\n      $document = jQuery(window.document);\n\n    util.disableScrollAround._count = util.disableScrollAround._count || 0;\n    ++util.disableScrollAround._count;\n    if (util.disableScrollAround._enableScrolling) return util.disableScrollAround._enableScrolling;\n    var body = $document[0].body,\n      restoreBody = disableBodyScroll(),\n      restoreElement = disableElementScroll();\n\n    return util.disableScrollAround._enableScrolling = function () {\n      if (!--util.disableScrollAround._count) {\n        restoreBody();\n        restoreElement();\n        delete util.disableScrollAround._enableScrolling;\n      }\n    };\n\n    // Creates a virtual scrolling mask to absorb touchmove, keyboard, scrollbar clicking, and wheel events\n    function disableElementScroll() {\n      var zIndex = 50;\n      var scrollMask = jQuery(\n        '<div class=\"md-scroll-mask\" style=\"z-index: ' + zIndex + '\">' +\n        '  <div class=\"md-scroll-mask-bar\"></div>' +\n        '</div>');\n      body.appendChild(scrollMask[0]);\n\n      scrollMask.on('wheel', preventDefault);\n      scrollMask.on('touchmove', preventDefault);\n      $document.on('keydown', disableKeyNav);\n\n      return function restoreScroll() {\n        scrollMask.off('wheel');\n        scrollMask.off('touchmove');\n        scrollMask[0].parentNode.removeChild(scrollMask[0]);\n        $document.off('keydown', disableKeyNav);\n        delete util.disableScrollAround._enableScrolling;\n      };\n\n      // Prevent keypresses from elements inside the body\n      // used to stop the keypresses that could cause the page to scroll\n      // (arrow keys, spacebar, tab, etc).\n      function disableKeyNav(e) {\n        //-- temporarily removed this logic, will possibly re-add at a later date\n        return;\n        if (!element[0].contains(e.target)) {\n          e.preventDefault();\n          e.stopImmediatePropagation();\n        }\n      }\n\n      function preventDefault(e) {\n        e.preventDefault();\n      }\n    }\n\n    // Converts the body to a position fixed block and translate it to the proper scroll\n    // position\n    function disableBodyScroll() {\n      var htmlNode = body.parentNode;\n      var restoreHtmlStyle = htmlNode.getAttribute('style') || '';\n      var restoreBodyStyle = body.getAttribute('style') || '';\n      var scrollOffset = body.scrollTop + body.parentElement.scrollTop;\n      var clientWidth = body.clientWidth;\n\n      if (body.scrollHeight > body.clientHeight) {\n        applyStyles(body, {\n          position: 'fixed',\n          width: '100%',\n          top: -scrollOffset + 'px'\n        });\n\n        applyStyles(htmlNode, {\n          overflowY: 'scroll'\n        });\n      }\n\n\n      if (body.clientWidth < clientWidth) applyStyles(body, {overflow: 'hidden'});\n\n      return function restoreScroll() {\n        body.setAttribute('style', restoreBodyStyle);\n        htmlNode.setAttribute('style', restoreHtmlStyle);\n        body.scrollTop = scrollOffset;\n      };\n    }\n\n    function applyStyles(el, styles) {\n      for (var key in styles) {\n        el.style[key] = styles[key];\n      }\n    }\n  },\n  enableScrolling: function () {\n    var method = this.disableScrollAround._enableScrolling;\n    method && method();\n  },\n\n  /**\n   * supplant() method from Crockford's `Remedial Javascript`\n   * Equivalent to use of $interpolate; without dependency on\n   * interpolation symbols and scope. Note: the '{<token>}' can\n   * be property names, property chains, or array indices.\n   */\n  supplant: function(template, values, pattern) {\n    pattern = pattern || /\\{([^\\{\\}]*)\\}/g;\n    return template.replace(pattern, function(a, b) {\n      var p = b.split('.'),\n        r = values;\n      try {\n        for (var s in p) {\n          if (p.hasOwnProperty(s) ) {\n            r = r[p[s]];\n          }\n        }\n      } catch (e) {\n        r = a;\n      }\n      return (typeof r === 'string' || typeof r === 'number') ? r : a;\n    });\n  }\n});\n\nexport default Util;\n","/home/travis/build/npmtest/node-npmtest-ember-paper/node_modules/ember-paper/app/utils/grid-layout.js":"export { default } from 'ember-paper/utils/grid-layout';"}